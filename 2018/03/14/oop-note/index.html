<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="learning note," />





  <link rel="alternate" href="/atom.xml" title="Hael's Blog" type="application/atom+xml" />






<meta name="description" content="Lecture 1 绪论序程序设计范型是指设计程序的规范、模型和风格，它是一类程序设计语言的基础。  面向过程程序设计范型：程序=过程+调用 或 程序=算法+数据结构 函数式程序设计范型：程序被看作“描述输入与输出之间关系”的数学函数。如LISP 面向对象程序设计是一种新型的程序设计范型。这种范型的主要特征是：对象=（算法+数据结构）程序=对象+消息  面向对象程序的主要结构特点：一、程序一般由类">
<meta name="keywords" content="learning note">
<meta property="og:type" content="article">
<meta property="og:title" content="面向对象程序设计课堂笔记">
<meta property="og:url" content="http://haelchan.me/2018/03/14/oop-note/index.html">
<meta property="og:site_name" content="Hael&#39;s Blog">
<meta property="og:description" content="Lecture 1 绪论序程序设计范型是指设计程序的规范、模型和风格，它是一类程序设计语言的基础。  面向过程程序设计范型：程序=过程+调用 或 程序=算法+数据结构 函数式程序设计范型：程序被看作“描述输入与输出之间关系”的数学函数。如LISP 面向对象程序设计是一种新型的程序设计范型。这种范型的主要特征是：对象=（算法+数据结构）程序=对象+消息  面向对象程序的主要结构特点：一、程序一般由类">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2018-07-08T01:55:17.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面向对象程序设计课堂笔记">
<meta name="twitter:description" content="Lecture 1 绪论序程序设计范型是指设计程序的规范、模型和风格，它是一类程序设计语言的基础。  面向过程程序设计范型：程序=过程+调用 或 程序=算法+数据结构 函数式程序设计范型：程序被看作“描述输入与输出之间关系”的数学函数。如LISP 面向对象程序设计是一种新型的程序设计范型。这种范型的主要特征是：对象=（算法+数据结构）程序=对象+消息  面向对象程序的主要结构特点：一、程序一般由类">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://haelchan.me/2018/03/14/oop-note/"/>





  <title>面向对象程序设计课堂笔记 | Hael's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hael's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://haelchan.me/2018/03/14/oop-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hael Chan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hael's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">面向对象程序设计课堂笔记</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-14T16:50:12+08:00">
                2018-03-14
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2018-07-08T09:55:17+08:00">
                2018-07-08
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/03/14/oop-note/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/03/14/oop-note/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2018/03/14/oop-note/" class="leancloud_visitors" data-flag-title="面向对象程序设计课堂笔记">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Lecture-1-绪论"><a href="#Lecture-1-绪论" class="headerlink" title="Lecture 1 绪论"></a>Lecture 1 绪论</h2><h3 id="序"><a href="#序" class="headerlink" title="序"></a>序</h3><p>程序设计范型是指设计程序的规范、模型和风格，它是一类程序设计语言的基础。</p>
<ul>
<li><strong>面向过程</strong>程序设计范型：程序=过程+调用 或 程序=算法+数据结构</li>
<li><strong>函数式</strong>程序设计范型：程序被看作“描述输入与输出之间关系”的数学函数。如LISP</li>
<li><strong>面向对象</strong>程序设计是一种新型的程序设计范型。这种范型的主要特征是：对象=（算法+数据结构）程序=对象+消息</li>
</ul>
<p>面向对象程序的主要结构特点：<br>一、程序一般由<strong>类的定义</strong>和<strong>类的使用</strong>两部分组成，在主程序中定义各对象并规定它们之间传递消息的规律。<br>二、程序中的一切操作都是通过<strong>向对象发送消息</strong>来实现的，对象接收到消息后，启动有关方法完成相应的操作。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>对象 Object</li>
<li>类 Class</li>
<li>消息 Message</li>
<li>方法 Method</li>
</ul>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>在现实世界中，任何事物都是对象。可以使有形的具体存在的事物，也可以是无形的抽象的事件。<br>对象一般可以表示为：<strong>属性+操作</strong></p>
<p><strong>名字</strong>：用于区别不同的实体<br><strong>属性/状态</strong>：属性用于描述不同实体的特征状态由这个对象的属性和这些属性的当前值决定。<br><strong>操作</strong>：用于描述不同实体可具有的行为是对象提供给用户的一种服务，也叫行为或方法。<br>· 对象的操作可以分为两类，一类是<strong>自身所承受</strong>的操作(private/protected)，一类是<strong>施加于其他对象</strong>的操作(public)。</p>
<p>方法(Method)——就是对象所能执行的操作，即服务。方法描述了对象执行操作的算法，响应消息的方法。在C++中称为<strong>成员函数</strong>。<br>属性(Attribute)——就是类中所定义的数据，它是对客观世界实体所具有性质的抽象。C++中称为<strong>数据成员</strong>。</p>
<p>在面向对象程序设计中，对象是描述其属性的<strong>数据</strong>及对这些数据施加的一组<strong>操作</strong>封装在一起构成的<strong>统一体</strong>。<br>对象可以认为是：<strong>数据+方法（操作）</strong></p>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>在现实世界中，<strong>类</strong>是一组具有相同<strong>属性</strong>和<strong>行为</strong>的对象的抽象。<br><strong>类</strong>和<strong>对象</strong>之间的关系式<strong>抽象</strong>和<strong>具体</strong>的关系。类是多个对象进行综合抽象的结果，一个对象是类的一个实例。<br>在面向对象程序设计中，类就是<strong>具有相同数据和相同操作的一组对象的集合</strong>。是对具有相同数据结构和相同操作的一类对象的描述。<br>在面向对象程序设计中，总是先声明类，再由类生成其对象。</p>
<p>注意不能把一组函数组合在一起构成类。即类不是函数的集合。</p>
<h4 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h4><p>面向对象设计技术必须提供一种机制允许一个对象与另一个对象的交互，这种机制叫<strong>消息传递</strong>。<br>在面向对象程序设计中，一个对象向另一个对象发出的<strong>请求</strong>被称为<strong>消息</strong>。当对象收到消息时，就调用有关的方法，执行相应的操作。<strong>消息是一个对象要求另一个对象执行某个操作的规格说明</strong>，通过消息传递才能完成对象之间的相互请求或相互协作。<br>消息具有三个性质：<br>(1).同一个对象可以接收不同形式的多个消息，作出不同的响应<br>(2).相同形式的消息可以传递给不同的对象，所作出的响应可以是不同的。<br>(3).对消息的响应并不是必需的，对象可以响应消息，也可以不响应。<br>分为两类：<strong>公有消息</strong>（其他对象发出），<strong>私有消息</strong>（向自己发出）。</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>方法就是对象所能执行的操作。方法包括界面和方法体两部分。<br>方法的<strong>界面</strong>（接口）就是消息的模式，它给出了方法调用的协议；<br><strong>方法体</strong>则是实现某种操作的一系列计算步骤，就是一段程序<br>在C++语言中方法是通过函数来实现的，称为<strong>成员函数</strong><br><strong>消息和方法的关系</strong>是：对象根据接收到的消息，调用相应的方法；反过来，有了方法，对象才能响应相应的消息。</p>
<h3 id="面向对象程序设计的基本特征"><a href="#面向对象程序设计的基本特征" class="headerlink" title="面向对象程序设计的基本特征"></a>面向对象程序设计的基本特征</h3><ul>
<li>抽象 Abstraction</li>
<li>封装 Encapsulation</li>
<li>继承 Inheritance</li>
<li>多态 Polymorphism</li>
</ul>
<h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><p>抽象是通过特定的实例（对象）抽取<strong>共同性质</strong>以后形成概念的过程。抽象是对系统的简化描述和规范说明，他强调了系统中的一部分细节和特性，而<strong>忽略了其他部分</strong>。<br>抽象包括两个方面，<strong>数据抽象</strong>和<strong>代码抽象</strong>（或称行为抽象）。前者描述某类对象的属性和状况，也就是此类对象区别于彼类对象的特征物理量；后者描述了某类对象的共同行为特征或具有的共同操作。<br>在面向对象的程序设计方法中，对一个具体问题的抽象分析结果，是通过<strong>类</strong>来<strong>描述和实现</strong>的。</p>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>在面向对象程序设计中，封装是指<strong>把数据和实现操作的代码</strong>集中起来放在对象内部，并尽可能隐藏对象的内部细节。<br>封装应该具有如下几个条件：<br>（1）对象具有一个清晰的边界，对象的私有数据和实现操作的代码被封装在该边界内。<br>（2）具有一个描述对象与其他对象如何相互作用的接口，该接口必须说明消息如何传递的使用方法。<br>（3）对象内部的代码和数据应受到保护，其他对象不能直接修改。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>继承是在一个已经建立的类的基础上再接着声明一个新类的扩展机制，原先已经建立的类称为<strong>基类</strong>，在基类之下扩展的类称为<strong>派生类</strong>，派生类又可以向下充当继续扩展的基类，因此构成层层派生的一个动态扩展过程。<br>派生类享有基类的数据结构和算法，而本身又具有增加的行为和特性，因此继承的机制促进了程序代码的可重用性。<br>一个基类可以有多个派生类，一个派生类反过来可以具有多个基类，形成复杂的继承树<strong>层次体系</strong>。</p>
<p>基类与派生类之间本质的关系：基类是一个简单的类，描述相对简单的事物，派生类是一个复杂些的类，处理相对复杂的现象。</p>
<p>继承的作用：<br>避免公用代码的重复开发，减少代码和数据冗余。<br>通过增强一致性来减少模块间的接口。<br>继承分为单继承和多继承。</p>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态性是指<strong>不同的对象收到相同的消息时产生多种不同的行为方式</strong>。<br>C++支持两种多态性：编译时的多态性（重载）和运行时的多态性（虚函数）。</p>
<p><strong>OOP的主要优点</strong><br>（1）可提高程序的重用性<br>（2）可控制程序的复杂性<br>（3）可改善程序的可维护性<br>（4）能够更好地支持大型程序设计<br>（5）增强了计算机处理信息的范围<br>（6）能很好地适应新的硬件环境</p>
<p><strong>C++的优点</strong><br>C++继承了C的优点，并有自己的特点，主要有：<br>（1）全面兼容C，C的许多代码不经修改就可以为C++所用，用C编写的库函数和实用软件可以用于C++。<br>（2）用C++编写的程序可读性更好，代码结构更为合理，可直接在程序中映射问题空间结构。<br>（3）生成代码的质量高，运行效率高。<br>（4）从开发时间、费用到形成软件的可重用性、可扩充性、可维护性和可靠性等方面有了很大提高，使得大中型的程序开发项目变得容易得多。<br>（5）支持面向对象的机制，可方便地构造出模拟现实问题的实体和操作。</p>
<h3 id="C-对C的补充"><a href="#C-对C的补充" class="headerlink" title="C++对C的补充"></a>C++对C的补充</h3><h4 id="注释与续行"><a href="#注释与续行" class="headerlink" title="注释与续行"></a>注释与续行</h4><p>注释符：<code>/* */</code>或<code>//</code><br>续行符：<code>\</code>。当一个语句太长时可以用该符号分段写在几行中<br>note: 其实不加续航符直接换行也可以0.0<br>E.g.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello "</span></div><div class="line">         &lt;&lt; <span class="string">"world"</span></div><div class="line">         &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div></pre></td></tr></table></figure>
<p>This program will print <code>hello world</code> in a line.</p>
<h4 id="输入输出流"><a href="#输入输出流" class="headerlink" title="输入输出流"></a>输入输出流</h4><p>C: <code>scanf</code>和<code>printf</code><br>C++: <code>cin&gt;&gt;</code>和<code>cout&lt;&lt;</code>（用C的也可以，但是不推荐……）<br>cout和cin分别是C++的标准输出流和输入流。C++支持重定向，但一般cout指的是屏幕，cin指的是键盘。操作符<code>&lt;&lt;</code>和<code>&gt;&gt;</code>除了具有C语言中定义的左移和右移的功能外，在这里符号<code>&lt;&lt;</code>是把右方的参数写到标准输出流cout中；相反，符号<code>&gt;&gt;</code>则是将标准输入流的数据赋给右方的变量。<br>cin和<code>&gt;&gt;</code>，cout和<code>&lt;&lt;</code>配套使用<br>使用cout和cin时，也可以对输入和输出的格式进行控制，比如可用不同的进制方式显示数据，只要设置转换基数的操作符dec、hex和oct即可。</p>
<h4 id="灵活的变量说明"><a href="#灵活的变量说明" class="headerlink" title="灵活的变量说明"></a>灵活的变量说明</h4><p>定义变量的位置<br>在程序中的不同位置采用不同的变量定义方式，决定了该变量具有不同的特点。变量的定义一般可由以下三种位置：<br>（1）函数体内部<br>在函数体内部定义的变量称为局部变量。<br>（2）形式参数<br>当定义一个有参函数时，函数名后面括号内的变量，统称为形式参数。<br>（3）全局变量：在所有函数体外部定义的变量，其作用范围是整个程序，并在整个程序运行期间有效。</p>
<p>在C语言中，全局变量声明必须在任何函数之前，局部变量必须集中在可执行语句之前。<br>C++中的变量声明非常灵活。它允许变量声明与可执行语句交替执行，随时声明。<code>for (int i = 0; i &lt; 10; i++)</code></p>
<h4 id="结构、联合和枚举名"><a href="#结构、联合和枚举名" class="headerlink" title="结构、联合和枚举名"></a>结构、联合和枚举名</h4><p>在C++中，结构名、联合名、枚举名都是类型名。在定义变量时，不必在结构名、联合名或枚举名前冠以struct、union或enum。<br>如：定义枚举类型<code>boole</code>: <code>enum boole{FALSE, TRUE};</code><br>在C语言中定义变量需写成<code>enum boole done;</code>，但在C++中，可以说明为<code>boole done;</code>。</p>
<h4 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h4><p>C语言<strong>建议</strong>编程者为程序中的每一个函数建立圆形，而C++<strong>要求</strong>为每一个函数建立原型，以说明函数的名称、参数类型与个数，以及函数返回值的类型。其主要目的是让C++编译程序进行类型检查，即形参与实参的类型匹配检查，以及返回值是否与原型相符，以维护程序的正确性。<br>在程序中，要求一个函数的原型出现在该函数的调用语句之前。说明：<br>（1）函数原型的参数表中<strong>可不包含参数的名字</strong>，而只包含它们的类型。例如<code>long Area(int, int);</code><br>（2）函数定义由函数首部和函数体构成。函数首部和函数原型基本一样，但函数首部中的参数必须给出名字而且不包含结尾的分号。<br>（3）C++的参数说明必须放在函数说明后的括号内，不可将函数参数说明放在函数首部和函数体之间。这种方法只在C中成立。<br>（4）主函数不必进行原型说明，因为它被看成自动说明原型的函数。<br>（5）原型说明中没有指定返回类型的函数（包括主函数main），C++默认该函数的返回类型是int。<br>（6）如果一个函数没有返回值，则必须在函数原型中注明返回类型为void，主函数类似处理。<br>（7）如果函数原型中未注明参数，C++假定该函数的参数表为空(void)。</p>
<h4 id="const修饰符"><a href="#const修饰符" class="headerlink" title="const修饰符"></a>const修饰符</h4><p>C语言中习惯用<code>#define</code>定义常量，C++利用const定义正规常数<br>一般格式 <code>const 数据类型标识符 常数名 = 常量值</code><br>采用这种方式定义的常量是类型化的，它有地址，可以用指针指向这个值，但不能修改它。<br>const必须放在被修饰类型符和类型名前面。<br>数据类型是可选项，用来指定常数值的数据类型，如果省略了数据类型，那么默认是int。<br>const的作用于<code>#define</code>相似，但它消除了<code>#define</code>的不安全性。</p>
<p>const可以与指针一起使用。<br>指向常量的指针、常指针和指向常量的常指针。<br>1）<strong>指向常量的指针</strong>是指：一个指向常量的指针变量。<br>2）<strong>常指针</strong>是指：把指针本身，而不是它指向的对象声明为常量。<br>3）<strong>指向常量的常指针</strong>是指：这个指针本身不能改变，它所指向的值也不能改变。要声明一个指向常量的常指针，二者都要声明为const。</p>
<p>说明：<br>（1）如果用const定义的是一个整型变量，关键词int<strong>可以省略</strong>。<br>（2）常量一旦被建立，在程序的任何地方都<strong>不能再更改</strong>。<br>（3）与<code>#define</code>定义的常量有所不同，const定义的常量可以<strong>有自己的数据类型</strong>，这样C++的编译程序可以进行更加严格的类型检查，具有良好的编译时的检测性。<br>（4）函数参数也可以用const说明，用于保证实参在该函数内部不被改动。</p>
<h4 id="void型指针"><a href="#void型指针" class="headerlink" title="void型指针"></a>void型指针</h4><p>void通常表示无值，但将void作为指针的类型时，它却表示<strong>不确定的类型</strong>。这种void型指针是一种通用型指针，也就是说任何类型的指针值都可以赋给void类型的指针变量。<br>void型指针可以接受任何类型的指针的赋值，但对已获值的void型指针，对它在进行处理，如输出或传递指针值时，则必须进行<strong>强制类型转换</strong>，否则会出错。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">void</span> *pc;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">456</span>;</div><div class="line">    <span class="keyword">char</span> c = <span class="string">'a'</span>;</div><div class="line">    pc = &amp;i;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; *(<span class="keyword">int</span> *)pc &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    pc = &amp;c;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; *(<span class="keyword">char</span> *)pc &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h4><p>调用函数时系统要付出一定的开销，用于信息入栈出栈和参数传递等。<br>C++引进了内联函数(inline function)的概念。在进行程序的编译时，编译器将内联函数的目标代码作拷贝并将其插入到调用内联函数的地方。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">circle</span><span class="params">(<span class="keyword">double</span> r)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">3.1416</span> * r * r;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"r = "</span> &lt;&lt; i &lt;&lt; <span class="string">" area = "</span> &lt;&lt; circle(i) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>说明：<br>（1）内联函数在第一次被调用前必须进行声明或定义。否则编译器无法知道应该插入什么代码<br>（2）C++的内联函数具有与C中的宏定义<code>#define</code>相同的作用和类似机理，但消除了<code>#define</code>的不安全性。<br>（3）内联函数体内一般不能有循环语句和开关语句。<br>（4）后面类结构中所有在类说明体内定义的函数都是内联函数。<br>（5）通常较短的函数才定义为内联函数。</p>
<h4 id="带有缺省参数值的函数"><a href="#带有缺省参数值的函数" class="headerlink" title="带有缺省参数值的函数"></a>带有缺省参数值的函数</h4><p>在C++中，函数的参数可以有缺省值。当调用有缺省参数的函数时，如果相应的参数没有给出实参，则自动用相应的缺省参数作为其实参。函数的缺省参数，是在<strong>函数原型</strong>中给定的。<br>说明<br>（1）在<strong>函数原型</strong>中，所有取缺省值的参数必须出现在不取缺省值的参数的右边。<br>（2）在<strong>函数调用</strong>时，若某个参数省略，则其后的参数皆应省略而采用缺省值。</p>
<h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>函数重载是指一个函数可以和<strong>同一作用域</strong>中的其他函数具有<strong>相同的名字</strong>，但这些同名函数的<strong>参数类型</strong>、<strong>参数个数</strong>不同。<br>为什么要使用函数重载？<br>对于具有同一功能的函数，如果只是由于参数类型不一样，则可以定义相同名称的函数。</p>
<p>调用步骤：<br>（1）寻找一个严格的匹配，即：调用与实参的数据类型、个数完全相同的那个函数。<br>（2）通过内部转换寻求一个匹配，即：通过（1）的方法没有找到相匹配的函数时，则由C++系统对实参的数据类型进行内部转换，转换完毕后，如果有匹配的函数存在，则执行该函数。<br>（3）通过用户定义的转换寻求一个匹配，若能查出有唯一的一组转换，就调用那个函数。即：在函数调用处由程序员对实参进行<strong>强制类型转换</strong>，以此作为查找相匹配的函数的依据。</p>
<p>注意事项：<br>重载函数不能只是函数的返回值不同，应至少在<strong>形参的个数</strong>、参数<strong>类型</strong>或参数<strong>顺序</strong>上有所不同。<br>应使所有的重载函数的功能相同。如果让重载函数完成不同的功能，会破坏程序的可读性。</p>
<p><strong>函数模板</strong><br>函数模板：建立一个通用函数，其函数类型和形参类型不具体指定，而是一个虚拟类型。<br>应用情况：凡是函数体相同的函数都可以用这个模板来代替，不必定义多个函数，只需在模板中定义一次即可。在调用函数时系统会根据实参的类型来取代模板中的虚拟类型，从而实现了不同函数的功能。<br><code>template&lt;typename T&gt;通用函数定义</code>，<code>template&lt;class T&gt;通用函数定义</code>(class和typename可以通用)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">if</span> (b &gt; a) <span class="keyword">return</span> b;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">return</span> a;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>与重载函数比较：用函数模板比函数重载更方便，程序更简洁。但应注意它只适用于：<strong>函数参数个数相同而类型不同，且函数体相同</strong>的情况。如果参数的个数不同，则不能用函数模板。</p>
<h4 id="作用域标识符"><a href="#作用域标识符" class="headerlink" title="作用域标识符::"></a>作用域标识符::</h4><p>通常情况下，如果有两个同名变量，一个是全局的，另一个是局部的，那么局部变量在其作用域内具有较高的优先权。<br>在全局变量加上<code>::</code>，此时<code>::var</code>代表全局变量。</p>
<h4 id="无名联合"><a href="#无名联合" class="headerlink" title="无名联合"></a>无名联合</h4><p>无名联合是C++中的一种特殊联合，可以声明一组无标记名共享同一段内存地址的数据项。如: <code>union {int i; float j;}</code><br>在此无名联合中，声明了变量i和f具有相同的存储地址。无名联合可通过使用其中数据项名字直接存取，例如可以直接使用上面的变量i或f。</p>
<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>C中数据类型转换的一般形式 (数据类型标识符) 表达式<br>C++支持这样的格式，还提供了一种更为方便的函数调用方法，即将类型名作为函数名使用，是的类型转换的执行看起来好像调用了一个函数。形式为：数据类型标识符 (表达式)。<br>推荐使用后一种方式。</p>
<h4 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h4><p>作为对C语言中malloc和free的替换，C++引进了new和delete操作符。它们的功能是<strong>实现内存的动态分配和释放</strong>。<br><code>指针变量=new 数据类型;</code><br>或<br><code>指针变量=new 数据类型(初始值);</code></p>
<p>例如：<br><code>int *a, *b;</code><br><code>a = new int;</code><br><code>b = new int(10);</code></p>
<p>释放由new操作动态分配的内存时，用delete操作。<br><code>delete 指针变量;</code><br>例如<code>delete a;</code>，<code>delete b;</code>。</p>
<p>优点：<br>（1）new和delete操作自动计算需要分配和释放类型的长度。这不但<strong>省去了用sizeof计算长度</strong>的步骤，更主要的是避免了内存分配和释放时因长度出错带来的严重后果。<br>（2）new操作自动返回需分配类型的指针，<strong>无需使用强制类型转换</strong>。<br>（3）new操作能初始化所分配的类型变量。<br>（4）new和delete都<strong>可以被重载</strong>，允许建立自定义的内存管理法。</p>
<p>说明：<br>（1）用new分配的空间，使用结束后应该用delete显示的释放，否则这部分空间将不能回收而变成死空间。<br>（2）使用new动态分配内存时，如果没有足够的内存满足分配要求，new将返回空指针（NULL）。因此通常要对内存的动态分配是否成功进行检查。<br>（3）使用new可以为数组动态分配内存空间。这时需要在类型后面加上数组大小。<br><code>指针变量 = new 类型名[下标表达式];</code><br>使用new为多维数组分配空间时，必须提供所有维的大小。<br>（4）释放动态分配的数组存储区时，可使用delete运算符，语法格式为<code>delete []指针变量;</code><br>（5）new 可在为简单变量分配内存空间的同时，进行初始化。这时的语法形式为：<br><code>指针变量 = new 类型名(初始值列表)</code></p>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>引用就是某一变量（目标）的一个别名，这样对引用的操作就是对目标的操作。<br>引用的声明方法：<code>类型标识符 &amp;引用名=目标变量名;</code><br>说明：<br>（1）<code>&amp;</code>在此不是求地址运算，而是起标识作用。<br>（2）<strong>类型</strong>标识符是指目标变量的类型。<br>（3）声明引用时，必须同时对其进行<strong>初始化</strong>。<br>（4）引用声明完毕后，相当于目标变量名有两个名称。<br>（5）声明一个引用，不是新定义了一个变量，系统并不给引用分配存储单元。</p>
<p>引用的使用<br>（1）引用名可以是任何合法的变量名。除了用作函数的参数或返回类型外，在声明时，必须立即对它进行初始化，不能声明完后再赋值。<br>（2）引用不能重新赋值，不能再把该引用名作为其他变量名的别名，任何对该引用的赋值就是该引用对应的目标变量名的赋值。对引用求地址，就是对目标变量求地址。<br>（3）由于指针变量也是变量，所以，可以声明一个指针变量的引用。方法是<code>类型标识符 *&amp;引用名=指针变量名</code><br>（4）引用是对某一变量或目标对象的引用，它本身不是一种数据类型，因此引用本身不占存储单元，这样，就不能声明引用的引用，也不能定义引用的指针。<br>（5）不能建立数组的引用，因为数组是一个由若干个元素所组成的集合，所以就无法建立一个数组的别名。<br>（6）不能建立空指针的引用。<br>（7）不能建立空类型void的引用。<br>（8）尽管引用运算符与地址操作符使用相同的符号，但是不一样的。引用仅在声明时带有引用运算符<code>&amp;</code>，以后就像普通变量一样使用，不能再带<code>&amp;</code>。其他场合使用的<code>&amp;</code>都是地址操作符。</p>
<p>用引用作为函数的参数<br>一个函数的参数可以定义成引用的形式。<br>在主调函数的调用点处，直接以<strong>变量</strong>作为<strong>实参</strong>进行调用即可，不需要实参变量有任何的特殊要求。</p>
<p>用引用返回函数值<br>函数可以返回一个引用，将函数说明为返回一个引用。<br>主要目的是：为了将函数用在赋值运算符的左边。要以引用返回函数值。<br><code>类型标识符 &amp;函数名 (形参列表及类型说明){函数体}</code><br>（1）以引用返回函数值，定义函数时需要在函数名前加<code>&amp;</code><br>（2）用引用返回一个函数值的最大好处是，在内存中不产生返回值的副本。<br>在定义返回引用的函数时，注意不要返回该函数内的自动变量（局部变量）的引用，由于自动变量的生存期仅限于函数内部，当函数返回时，自动变量就消失了。</p>
<p>一个返回引用的函数值<strong>作为赋值表达式的左值</strong>。<br>一般情况下，赋值表达式的左边只能是变量名，即被赋值的对象必须是变量，只有变量才能被赋值。</p>
<h2 id="Lecture-2-类和对象"><a href="#Lecture-2-类和对象" class="headerlink" title="Lecture 2 类和对象"></a>Lecture 2 类和对象</h2><h3 id="类的构成"><a href="#类的构成" class="headerlink" title="类的构成"></a>类的构成</h3><p>类是C++对C中结构的扩展。<br>C语言中的struct是数据成员集合，而C++中的类，则是数据成员和成员函数的集合。<br>struct是用户定义的数据类型，是一种构造数据类型。类和struct一样，也是一种用户定义的数据类型，是一种构造数据类型。<br>C结构无法对数据进行保护和权限控制，所以结构中的数据是不安全的。C++中的类将数据和与之相关联的数据封装在一起，形成一个整体，具有良好的外部接口可以防止数据未经授权的访问，提供了模块间的独立性。</p>
<p>类的成员分两部分：一部分对应数据的状态，称为数据成员，另一部分作用于该数据状态的函数，称为成员函数。</p>
<h4 id="private-protected-public"><a href="#private-protected-public" class="headerlink" title="private, protected, public"></a>private, protected, public</h4><p>· <code>private</code> 部分称为类的私有部分，这一部分的数据成员和成员函数称为类的私有成员。私有成员只能由本类的成员函数访问，而类外部的任何访问都是非法的。（只能在定义、实现的时候访问）<br>· <code>public</code> 部分称为类的共有部分，这部分的数据成员和成员函数称为类的公有成员。公有成员可以由程序中的函数访问，它对外是完全开放的。<br>· <code>protected</code> 部分称为类的保护部分，这部分的数据成员和成员函数称为类的保护成员。保护成员可以由本类的成员函数访问，也可以由本类的派生类的成员函数访问，而类外的任何访问都是非法的。</p>
<p>（1）类声明格式中的3个部分并非一定要全有，但至少要有其中的一个部分。<br>一般一个类的数据成员应该声明为私有成员，成员函数声明为公有成员。<br>（2）类声明中的private, protected, public三个关键字可以按任意顺序出现任意次。但是，如果把所有的私有成员、保护成员和公有成员归类放在一起，程序将更加清晰。<br>（3）private处于类体重第一部分时，关键字private可以省略。<br>（4）数据成员可以是任何数据类型，但不能用自动(auto)、寄存器(register)或外部(extern)进行声明。<br>（5）不能在类声明中给数据成员赋值。C++规定，只有在类对象定义之后才能给数据成员赋初值。</p>
<h3 id="成员函数的声明"><a href="#成员函数的声明" class="headerlink" title="成员函数的声明"></a>成员函数的声明</h3><p>普通成员函数形式<br>在类的声明中(.h)只给出成员函数的原型，而成员函数体写在类的外部(.cpp)。</p>
<p>内联函数形式<br>直接将函数声明在类内部；<br>在类声明中只给出成员函数的原型，而成员函数体写在类的外部，在成员函数返回类型前冠以关键字<code>inline</code>。</p>
<h3 id="对象的定义和使用"><a href="#对象的定义和使用" class="headerlink" title="对象的定义和使用"></a>对象的定义和使用</h3><p>在C++中，可以把相同数据结构和相同操作集的对象看成属于同一类。<br>当定义了一个类的对象后，就可以访问对象的成员了。在类的外部可以通过类的对象对<strong>公有成员</strong>进行访问，访问对象成员要使用操作符<code>.</code>（称为对象选择符，简称点运算符）。<br>在定义对象时，若定义的是指向对象的指针，则访问此对象的成员时，要用<code>-&gt;</code>操作符。</p>
<p>在类的内部所有成员之间都可以通过成员函数直接访问，但是类的外部不能访问对象的私有成员。</p>
<p>类成员的访问属性<br>说明为public的成员不但可以被类中成员函数访问；还可以在类的外部，通过类的对象进行访问<br>说明为private的成员只能被类中成员函数访问，不能在类的外部，通过类的对象进行访问<br>说明为protected的成员除了类本身的成员函数可以访问外，该类的派生类的成员也可以访问，但不能在类的外部，通过类的对象进行访问</p>
<p>类的成员对类对象的可见性和对类的成员函数的可见性是不同的。<br>类的成员函数可以访问类的所有成员，而类的对象对类的成员的访问是受类成员的访问属性的制约的。</p>
<p>一般来说，公有成员是类的对外接口，而私有成员和保护成员是类的内部数据和内部实现，不希望外界访问。将类的成员划分为不同的访问级别有两个好处：一是<strong>信息隐蔽</strong>，即实现封装；二是<strong>数据保护</strong>，即将类的重要信息保护起来，以免其他程序不恰当地修改。</p>
<p>对象赋值语句<br>两个同类型的变量之间可以相互赋值。同类型的对象间也可以进行赋值，当一个对象赋值给另一个对象时，所有的数据成员都会逐位拷贝。<br>说明：<br>·在使用对象赋值语句进行对象赋值时，两个对象的类型必须相同，如果对象的类型不同，编译时将出错。<br>·两个对象之间的赋值，仅仅使这些对象中数据成员相同，而两个对象仍是分离的。<br>·<code>=</code>的对象赋值是通过缺省的赋值运算符函数实现的。（复杂的需要重载）<br>·当类中存在指针时，使用缺省的赋值运算符进行对象赋值，可能会产生错误。</p>
<h3 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h3><p>构造函数和析构函数都是类的成员函数，但它们都是特殊的成员函数，执行特殊的功能，不用调用便自动执行，而且这些函数的名字与类的名字有关。<br>C++语言中有一些成员函数性质是特殊的，这些成员函数负责对象的建立、删除。这些函数的特殊性在于可以由编译器自动地隐含调用，其中一些函数调用格式采用运算符函数重载的语法。C++引进一个自动完成对象初始化过程的机制，这就是类的构造函数。</p>
<p>对象的初始化<br>1）数据成员是不能在声明类时初始化<br>2）类型对象的初始化方法：<br>·调用对外接口(public成员函数)实现 声明类→定义对象→调用接口给成员赋值<br>·应用构造函数(constructor)实现 声明类→定义对象→同时给成员赋值</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>构造函数是一种特殊的成员函数，它主要用于为对象分配空间，进行初始化。构造函数具有一些特殊的性质：<br>（1）构造函数的名字必须与类名相同。<br>（2）构造函数可以有任意类型的参数，但不能指定返回类型。它有隐含的返回值，该值由系统内部使用。<br>（3）构造函数是特殊的成员函数，函数体可写在类体内，也可写在类体外。<br>（4）构造函数可以重载，即一个类中可以定义多个参数个数或参数类型不同的构造函数。构造函数不能继承。<br>（5）构造函数被声明为公有函数，但它不能像其他成员函数那样被显式地调用，它是在定义对象的同时调用的<br>·在声明类时如果没有定义类的构造函数，编译系统就会在编译时自动生成一个默认形式的构造函数。<br>·默认构造函数是构造对象时不提供参数的构造函数。<br>·除了无参数构造函数是默认构造函数外，带有全部默认参数值的构造函数也是默认构造函数。<br>·自动调用：构造函数在定义类对象时自动调用，不需用户调用，也不能被用户调用。在对象使用前调用。<br>·调用顺序：在对象进入其作用域时（对象使用前）调用构造函数。</p>
<p>利用构造函数创建对象的两种方法：<br>（1）利用构造函数直接创建对象，其一般形式为：<code>类名 对象名[(实参表)];</code><br>这里的“类名”与构造函数名相同，“实参表”是为构造函数提供的实际参数。<br>（2）利用构造函数创建对象时，通过指针和new来实现。其一般语法形式为：<code>类名 *指针变量 = new 类名 [(实参表)];</code></p>
<h4 id="成员初始化表"><a href="#成员初始化表" class="headerlink" title="成员初始化表"></a>成员初始化表</h4><p>对于常量类型和引用类型的数据成员，不能在构造函数中用赋值语句直接赋值，C++提供初始化表进行置初值。</p>
<p>类名::构造函数名([参数表])[:(成员初始化表)]<br>成员初始化表的一般形式为：数据成员名1(初始值1),数据成员名2(初始值2),…</p>
<p>如果需要将数据成员存放在堆中或数组中，则应在构造函数中使用赋值语句，即使构造函数有成员初始化表也应如此。</p>
<p>类成员是按照它们在类里被声明的顺序初始化的，与它们在初始化表中列出的顺序无关。</p>
<h4 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h4><p>拷贝构造函数是一种特殊的构造函数，其形参是本类对象的引用。其作用是使用一个已经存在的对象去初始化另一个同类的对象。<br>通过等号复制对象时，系统会自动调用拷贝构造函数</p>
<p>拷贝函数特点：<br>该函数也是一种构造函数，所以其函数名与类名相同，并且该函数也没有返回值类型<br>该函数只有一个参数，并且是同类对象的引用<br>每个类必须有一个拷贝构造函数。可以根据需要定义特定的拷贝构造函数，以实现同类对象之间数据成员的传递。如果没有定义类的拷贝构造函数，系统就会自动生成产生一个缺省的拷贝构造函数</p>
<p>缺省的拷贝构造函数<br>如果没有编写自定义的拷贝构造函数，C++会自动地将一个已存在的对象复制给新对象，这种按成员逐一复制的过程是由缺省拷贝构造函数自动完成的。</p>
<p>调用拷贝构造函数的三种情况：<br>（1）当用类的一个对象去初始化该类的另一个对象时。（代入法与赋值法）<br>（2）当函数的形参是类的对象，调用函数，进行形参和实参结合时。<br>（3）当函数的返回值是对象，函数执行完成，返回调用者时。</p>
<p>浅拷贝与深拷贝<br>所谓浅拷贝，就是由缺省的拷贝构造函数所实现的数据成员逐一赋值，若类中含有指针类型数据，则会产生错误。<br>为了解决浅拷贝出现的错误，必须显示地定义一个自己的拷贝构造函数，使之不但拷贝数据成员，而且为对象1和对象2分配各自的内存空间，这就是所谓的深拷贝。</p>
<h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><p>析构函数也是一种特殊的成员函数。它执行与构造函数相反的操作，通常用于撤销对象时的一些清理任务，如释放分配给对象的内存空间等。<br>析构函数有以下一些特点：<br>①析构函数与构造函数名字相同，但它前面必须加一个波浪号(~)；<br>②析构函数没有参数，也没有返回值，而且不能重载。因此在一个类中只能有一个析构函数；<br>③当撤销对象时，编译系统会自动调用析构函数。如果程序员没有定义析构函数，系统将自动生成和调用一个默认析构函数，默认析构函数只能释放对象的数据成员所占用的空间，但不包括堆内存空间。</p>
<p>析构函数被调用的两种情况：<br>(1)若一个对象被定义在一个函数体内，当这个函数结束时，析构函数被自动调用。<br>(2)若一个对象是使用new运算符动态创建，在使用delete释放时，自动调用析构函数。</p>
<h4 id="调用构造函数和析构函数的顺序"><a href="#调用构造函数和析构函数的顺序" class="headerlink" title="调用构造函数和析构函数的顺序"></a>调用构造函数和析构函数的顺序</h4><p>1） 一般顺序：调用析构函数的次序正好与调用构造函数的次序相反：最先被调用的构造函数，其对应的析构函数最后被调用，而最后被调用的构造函数，其对应的析构函数最先被调用。<br>2） 全局对象：在全局范围中定义的对象（即在所有函数之外定义的对象），它的构造函数在所有函数（包括main函数）执行之前调用。在程序的流程离开其作用域时（如main函数结束或调用exit函数）时，调用该全局对象的析构函数。<br>3） auto局部对象：局部自动对象（例如在函数中定义的对象），则在建立对象时调用其构造函数。如果函数被多次调用，则在每次建立对象时都要调用构造函数。在函数调用结束、对象释放时先调用析构函数。<br>4） static局部对象：如果在函数中定义静态局部对象，则只在程序第一次调用此函数建立对象时调用构造函数一次，在调用结束时对象并不释放，因此也不调用析构函数，只在main函数结束或调用exit函数结束程序时，才调用析构函数。</p>
<p>对象的生存期<br>（1）局部对象：当对象被定义时，调用构造函数，该对象被创建；当程序退出该对象所在的函数体或程序块时，调用析构函数，对象被释放。<br>（2）全局对象：当程序开始运行时，调用构造函数，该对象被创建；当程序结束时，调用析构函数，该对象被释放。<br>（3）静态对象：当程序中定义静态对象时，调用构造函数，该对象被创建；当整个程序结束时，调用析构函数，对象被释放。<br>（4）动态对象：执行new运算符调用构造函数，动态对象被创建；用delete释放对象时，调用析构函数。<br>局部对象是倍定义在一个函数体或程序块内的，它的作用域限定在函数体或程序块内，生存期较短。<br>静态对象是被定义在一个文件中，它的作用域从定义时起到文件结束时为止。生存期较长。<br>全局对象是被定义在某个文件中，它的作用域包含在该文件的整个程序中，生存期是最长的。<br>动态对象是由程序员掌握的，它的作用域和生存期是由new和delete之间的间隔决定的。</p>
<h2 id="Lecture-3-类和对象"><a href="#Lecture-3-类和对象" class="headerlink" title="Lecture 3 类和对象"></a>Lecture 3 类和对象</h2><h3 id="自引用指针this"><a href="#自引用指针this" class="headerlink" title="自引用指针this"></a>自引用指针this</h3><p>每一个类的成员函数都有一个隐藏定义的常量指针，称为this指针。<br>this指针的类型就是成员函数所属的类的类型。<br>每当调用成员函数时，它被初始化为被调函数所在类的对象的地址。也就是自动地将对象的指针传给它。不同的对象调用同一个成员函数时，编译器将根据成员函数的this指针所指向的对象来确定应该引用哪一个对象的数据成员。<br>在通常情况下，this指针在系统中是隐含地存在的，也可以显示地表示出来。</p>
<p>this指针是一个const指针，不能在程序中修改它或给它赋值。<br>this指针是一个局部数据，它的作用域仅在一个对象的内部。</p>
<h3 id="对象数组与对象指针"><a href="#对象数组与对象指针" class="headerlink" title="对象数组与对象指针"></a>对象数组与对象指针</h3><h4 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h4><p>所谓对象数组是指每一数组元素都是对象的数组。<br>与基本数据类型的数组一样，在使用对象数组时也只能访问单个数组元素，也就是一个对象，通过这个对象，也可以访问到它的公有成员。<br>如果需要建立某个类的对象数组，在设计类的构造函数时要充分考虑到数组元素初始化的需要：<br>当各个元素的初值要求为相同的值时，应该在类中定义出不带参数的构造函数或带缺省参数值的构造函数<br>当各元素对象的初值要求为不同的值时需要定义带形参（无缺省值）的构造函数<br>定义对象数组时，可通过初始化表进行赋值</p>
<h4 id="对象指针"><a href="#对象指针" class="headerlink" title="对象指针"></a>对象指针</h4><p>每一个对象在初始化后都会在内存中占有一定的空间。因此，既可以通过对象名访问一个对象，也可以通过对象地址来访问一个对象。对象指针就是用于存放对象地址的变量。<code>类名 * 对象指针名</code></p>
<p>用指针访问单个对象成员<br>初始化指向一个已创建的对象，用<code>-&gt;</code>操作符访问对象的公有成员</p>
<p>用对象指针访问对象数组<br>对象指针++即指向下一个数组对象元素</p>
<p>指向类的成员的指针<br>类的成员自身也是一些变量、函数或者对象等，因此也可以直接将它们的地址存放到一个指针变量中，这样就可以使指针直接指向对象的成员，进而可以通过指针访问对象的成员。<br>指向成员的指针只能访问公有数据成员和成员函数。<br>使用要先声明，再赋值，然后访问。<br><strong>指向数据成员的指针</strong><br>声明：<code>类型说明符 类名::*数据成员指针名</code><br>赋值：<code>数据成员指针名 = &amp;类名::数据成员名</code><br>使用：<code>对象名.*数据成员指针名</code> <code>对象指针名-&gt;*数据成员指针名</code></p>
<p><strong>指向成员函数的指针</strong><br>声明：<code>类型说明符 (类名:: *指针名)(参数表)</code><br>赋值：<code>成员函数指针名 = 类名::成员函数名</code><br>使用：<code>(对象名.*成员函数指针名)(参数表)</code> <code>(对象指针名-&gt;*成员函数指针名)(参数表)</code></p>
<h3 id="向函数传递对象"><a href="#向函数传递对象" class="headerlink" title="向函数传递对象"></a>向函数传递对象</h3><p><strong>对象</strong>可以作为参数传递给函数，其方法与传递其他类型的数据相同。在向函数传递对象时，是通过传值调用传递给函数的。因此，函数中对对象的任何修改均不影响调用该函数的对象本身。<br><strong>对象指针</strong>可以作为函数的参数，使用对象指针作为函数参数可以实现传址调用，即可在被调用函数中改变函数的参数对象的值，实现函数之间的信息传递。同时使用对象指针实参仅将对象的地址值传给形参，而不进行副本的拷贝，这样可以提高运行效率，减少时空开销。<br>使用<strong>对象引用</strong>作为函数参数不但具有用对象指针作函数参数的优点，而且用对象引用作函数参数将更简单、更直接。</p>
<h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>引入目的：实现一个类的不同对象之间数据和函数共享</p>
<p><strong>静态数据成员</strong><br>用关键字<code>static</code>声明<br>该类的所有对象维护该成员的同一个拷贝<br>必须在类外定义和初始化，用<code>(::)</code>来指明所属的类<br>与一般的数据成员不同，无论建立多少个类的对象，都只有一个静态数据的拷贝。从而实现了同一个类的不同对象之间的数据共享。它不因对象的建立而产生，也不因对象的析构而删除。<br>静态数据成员初始化的格式：<br><code>&lt;数据类型&gt;&lt;类名&gt;::&lt;静态数据成员名&gt;=&lt;值&gt;;</code><br>初始化时使用作用域运算符来标明它所属的类，因此，静态数据成员是类的成员，而不是对象的成员。<br>引用静态数据成员时，采用如下格式：<br><code>&lt;类名&gt;::&lt;静态成员名&gt;</code></p>
<p>如何使用静态数据成员？<br>(1)静态数据成员的定义与一般数据成员相似，但前面要加上static关键词<br>(2)静态数据成员的初始化与一般数据成员不同。初始化位置在定义对象之前，一般在类定义后，main()前进行<br>(3)访问方式（只能访问公有静态数据成员）<br>可用类名访问：<code>类名::静态数据成员</code><br>也可用对象访问：<code>对象名.静态数据成员</code>,<code>对象指针-&gt;静态数据成员</code><br>(4)私有静态数据成员不能被类外部函数访问，也不能用对象进行访问<br>(5)支持静态数据成员的一个主要原因是可以不必使用全局变量。静态数据成员的主要用途是定义类的各个对象所公用的数据。</p>
<p><strong>静态成员函数</strong><br>类外代码可以使用类名和作用域符来调用公有静态成员函数<br>静态成员函数只能引用属于该类的静态数据成员或静态成员函数。访问非静态数据成员，必须通过参数传递方式得到对象名，通过对象名访问。</p>
<p>可以通过定义和使用静态成员函数来访问静态数据成员。<br>所谓静态成员函数就是使用static关键字声明函数成员。同静态数据成员一样，静态成员函数也属于整个类，由同一个类的所有对象共同维护，为这些对象所共享。<br>静态成员函数作为成员函数，它的访问属性可以受到类的严格控制。对公有静态成员函数，可以通过类名或对象名来调用；而一般的非静态公有成员函数只能通过对象名来调用。<br>静态成员函数可以直接访问该类的静态数据成员和函数成员；而访问非静态数据成员，必须通过参数传递方式得到对象名，然后通过对象名来访问。<br>定义：<br><code>static 返回类型 静态成员函数名(参数表);</code><br>使用：<br><code>类名::静态成员函数名(实参表)</code><br><code>对象.静态成员函数名(实参表)</code><br><code>对象指针-&gt;静态成员函数名(实参表)</code></p>
<p>注意：<br>(1)静态成员函数可以定义成内嵌的，也可以在类外定义，在类外定义时不能用static前缀。<br>(2)静态成员函数主要用来访问全局变量或同一个类中的静态数据成员。特别是，当它与静态数据成员一起使用时，达到了对同一个类中对象之间共享数据进行维护的目的。<br>(3)私有静态成员函数不能被类外部函数和对象访问。<br>(4)使用静态成员函数的一个原因是，可以用它在建立任何对象之前处理静态数据成员。这是普通成员函数不能实现的。<br>(5)静态成员函数中没有指针this，所以静态成员函数不能访问类中的非静态数据成员，若确实需要则只能通过对象名作为参数访问。</p>
<p>可以通过指针访问静态数据成员和静态成员函数</p>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>友元可以访问与其有好友关系的类中的私有成员。友元包括友元函数和友元类。</p>
<h4 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h4><p>友元函数不是当前类的成员函数，而是独立于当前类的外部函数，但它可以访问该类的所有对象的成员，包括私有、保护和公有成员。</p>
<p>友元函数的声明：<br>位置：当前类体中<br>格式：函数名前加<code>friend</code><br>友元函数的定义：<br>类体外：同一般函数（函数名前不能加<code>类名::</code>）<br>类体内：函数名前加<code>friend</code></p>
<p>说明：<br>(1)友元函数毕竟不是成员函数，因此，在类的外部定义友元函数时，不能在函数名前加上<code>类名::</code>。<br>(2)友元函数一般带有一个该类的入口参数。因为友元函数不是类的成员函数，没有this指针，所以不能直接引用对象成员的名字，也不能通过this指针引用对象的成员，它必须通过作为入口参数传递进来的对象名或对象指针来引用该对象的成员。</p>
<p>引入友元机制的原因<br>(1)友元机制是对类的封装机制的补充，利用此机制，一个类可以赋予某些函数访问它的私有成员的特权。<br>(2)友元提供了不同类的成员函数之间、类的成员函数与一般函数之间进行数据互享的机制。</p>
<h4 id="友元成员函数"><a href="#友元成员函数" class="headerlink" title="友元成员函数"></a>友元成员函数</h4><p>一个类的成员函数也可以作为另一个类的友元，这种成员函数不仅可以访问自己所在类对象中的所有成员，还可以访问friend声明语句所在类对象中的所有成员。<br>这样能使两个类相互合作、协调工作，完成某一任务。<br>一个类的成员函数作为另一个类的友元函数时，必须先定义这个类。</p>
<h4 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h4><p>一个类也可以作为另一个类的友元。<br>类Y的所有成员函数都是类X的友元函数<br>在实际工作中，除非确有必要，一般并不把整个类声明为友元类，而只将确实有需要的成员函数声明为友元函数，这样更安全一些。</p>
<p>友元的关系是单向的而不是双向的。<br>友元的关系不能传递。</p>
<h3 id="共用数据的保护-const"><a href="#共用数据的保护-const" class="headerlink" title="共用数据的保护(const)"></a>共用数据的保护(const)</h3><p>const对象的一般形式<br><code>类型名 const 对象名[(构造实参表列)];</code><br><code>const 类型名 对象名[(构造实参表列)];</code><br>常对象必须要有初值。<br>定义为const的对象的所有数据成员的值都不能被修改。凡出现调用非const的成员函数，将出现编译错误。<br>对数据成员声明为mutable时，即使是const对象，仍然可以修改该数据成员值。</p>
<h4 id="常数据成员"><a href="#常数据成员" class="headerlink" title="常数据成员"></a>常数据成员</h4><p>用const声明的常数据成员，其值是不能改变的。只能通过构造函数的参数初始化表对场数据成员进行初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span> &#123;</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> hour;</div><div class="line">    Time(<span class="keyword">int</span> h):hour(h)&#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="常成员函数"><a href="#常成员函数" class="headerlink" title="常成员函数"></a>常成员函数</h4><p>成员函数声明中包含const时为常成员函数。此时，该函数只能引用本类中的数据成员，而不能修改它们，即成员数据不能作为语句的左值。(mutable可以)<br><code>类型说明符 函数名(参数表) const;</code><br><code>const</code>的位置在函数名和括号之后，是函数类型的一部分，在声明函数和定义函数时都要有const关键字。<br>如果将一个对象声明为常对象，则通过该对象只能调用它的常成员函数，而不能调用普通成员函数。而且常成员函数也不能更新对象的数据成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_Time</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"><span class="keyword">void</span> Time::show_Time <span class="keyword">const</span> &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; hour &lt;&lt; minute &lt;&lt; sec &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="指向常对象的指针变量"><a href="#指向常对象的指针变量" class="headerlink" title="指向常对象的指针变量"></a>指向常对象的指针变量</h3><p>指向常对象的指针变量的一般形式：<br><code>const 类型 *指针变量名</code></p>
<p>指向常对象（变量）的指针变量，不能通过它来改变所指向目标对象的值，但指针变量的值是可以改变的。<br>如果被声明为常对象（变量），只能用指向常对象（变量）的指针变量指向它，而不能非const型指针变量去指向它。<br>指向常对象（变量）的指针变量除了可以指向常对象（变量）外，还可以指向未被声明为const的对象（变量）。此时不能通过此指针变量改变该变量的值。<br>指向常对象（变量）的指针变量可以指向const和非const型的对象（变量），而指向非const型变量的指针变量只能指向非const的对象（变量）。<br>如果函数的形参是指向非const型变量的指针，实参只能用指向非const变量的指针，而不能用指向const变量的指针，这样，在执行函数的过程中可以改变形参指针变量所指向的变量的值。<br>如果函数形参是指向const型变量的指针，允许实参是指向const变量的指针，或指向非const变量的指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(Time *pt)</span></span>;</div><div class="line">Time *p1;</div><div class="line"><span class="keyword">const</span> Time *p2;</div><div class="line">f(p1);  <span class="comment">//正确</span></div><div class="line">f(p2);  <span class="comment">//错误</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">const</span> Time *pt)</span></span>;</div><div class="line">Time *p1;</div><div class="line"><span class="keyword">const</span> Time *p2;</div><div class="line">f(p1);  <span class="comment">//正确</span></div><div class="line">f(p2);  <span class="comment">//错误</span></div></pre></td></tr></table></figure>
<p>| Time const t = Time(1,2,3); const Time t = Time(1,2,3);<br>const int a = 10;<br>int const a = 10; | t是常对象，其成员值在任何情况下都不能被改变 a是常变量，其值不能被改变 |<br>| —- | —- |<br>| void Time::fun() const; | fun是Time类的常成员函数，可以调用该函数，但不能修改本类中的数据成员(非mutable) |<br>| Time <em> const pt; int </em> const pa; | pt是指向Time对象的常指针，pa是指向整数的常指针。指针值不能改变  |<br>| const Time <em>pt; const int </em>pa; | pt是指向Time类常对象的指针，pa是指向常整数的指针，不能通过指针来改变指向的对象（值） |</p>
<h2 id="Lecture-4-派生类与继承"><a href="#Lecture-4-派生类与继承" class="headerlink" title="Lecture 4 派生类与继承"></a>Lecture 4 派生类与继承</h2><h3 id="继承与派生类"><a href="#继承与派生类" class="headerlink" title="继承与派生类"></a>继承与派生类</h3><p>继承目的：代码的重用和代码的扩充<br>继承方法程序设计思路：一般-&gt;特殊<br>继承种类：单继承、多继承<br>继承方式：public protected private<br>继承内容：除构造函数、析构函数、私有成员外的其他成员</p>
<p>保持已有类的特性而构造新类的过程称为<strong>继承</strong>。<br>在已有类的基础上新增自己的特性而产生新类的过程称为<strong>派生</strong>。<br>被继承的已有类称为基类（父类）。<br>派生出的新类称为派生类。</p>
<h4 id="继承的访问控制"><a href="#继承的访问控制" class="headerlink" title="继承的访问控制"></a>继承的访问控制</h4><p>三种继承方式：public, private, protected<br>派生类成员的访问权限：inaccessible, public, private, protected</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>在基类中的访问属性</th>
<th>继承方式</th>
<th>在派生类中的访问属性</th>
</tr>
</thead>
<tbody>
<tr>
<td>private</td>
<td>public</td>
<td>inaccessible</td>
</tr>
<tr>
<td>private</td>
<td>private</td>
<td>inaccessible</td>
</tr>
<tr>
<td>private</td>
<td>protected</td>
<td>inaccessible</td>
</tr>
<tr>
<td>public</td>
<td>public</td>
<td>public</td>
</tr>
<tr>
<td>public</td>
<td>private</td>
<td>private</td>
</tr>
<tr>
<td>public</td>
<td>protected</td>
<td>protected</td>
</tr>
<tr>
<td>protected</td>
<td>public</td>
<td>protected</td>
</tr>
<tr>
<td>protected</td>
<td>private</td>
<td>private</td>
</tr>
<tr>
<td>protected</td>
<td>protected</td>
<td>protected</td>
</tr>
</tbody>
</table>
</div>
<p><strong>私有继承的访问规则</strong><br>基类的public成员和protected成员被继承后作为派生类的private成员，派生类的其他成员可以直接访问它们，但是在类外部通过派生类的对象无法访问。<br>基类的private成员在私有派生类中是不可直接访问的，所以无论是派生类成员还是通过派生类的对象，都无法直接访问从基类继承来的private成员，但是可以通过基类提供的public成员函数间接访问。<br>通过派生类的对象不能访问基类中的任何成员。</p>
<p><strong>公有继承的访问规则</strong><br>基类的public成员和protected成员被继承到派生类中仍作为派生类的public成员和protected成员，派生类的其他成员可以直接访问它们。但是，类的外部的使用者只能通过派生类的对象访问继承来的public成员。<br>派生类的对象只能访问基类的public成员。</p>
<p>1.派生的对象可以赋给基类的对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Derived d;      <span class="comment">// Derived public inherit from Base</span></div><div class="line">Base b;</div><div class="line">b = d;</div></pre></td></tr></table></figure>
<p>2.派生类的对象可以初始化基类的引用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Derived d;</div><div class="line">Base &amp;br = d;</div></pre></td></tr></table></figure>
<p>3.派生类的对象的地址可以赋给指向基类的指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Derived d;</div><div class="line">Base *pa = &amp;d;</div></pre></td></tr></table></figure>
<p>通过指针或引用只能访问对象d中所继承的基类成员。</p>
<p><strong>保护继承的访问规则</strong><br>基类的public成员和protected成员被继承到派生类中都作为派生类的protected成员，派生类的其他成员可以直接访问它们，但是类的外部使用者不能通过派生类的对象来访问它们。<br>通过派生类的对象不能访问基类中的任何成员。</p>
<p>基类与派生类的关系<br>派生类是基类的具体化<br>派生类是基类定义的延续<br>派生类是基类的组合</p>
<h3 id="派生类的构造函数和析构函数"><a href="#派生类的构造函数和析构函数" class="headerlink" title="派生类的构造函数和析构函数"></a>派生类的构造函数和析构函数</h3><p>基类的构造函数和析构函数不能被继承，一般派生类要加入自己的构造函数。</p>
<p>通常情况下，当创建派生类对象时，首先执行基类的构造函数，随后再执行派生类的构造函数；<br>当撤销派生类对象时，则先执行派生类的析构函数，随后再执行基类的析构函数。</p>
<p>当基类的构造函数没有参数，或没有显示定义构造函数时，派生类可以不向基类传递参数，甚至可以不定义构造函数；当基类含有带参数的构造函数时，派生类必须定义构造函数，以提供把参数传递给基类构造函数的途径。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">派生类名(参数总表):基类名(参数表)</div><div class="line">&#123;&#125;</div></pre></td></tr></table></figure>
<p>当派生类中含有内嵌对象成员时，其构造函数的一般形式为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">派生类名(参数总表):基类名(参数表<span class="number">1</span>),内嵌对象名<span class="number">1</span>(内嵌对象参数表<span class="number">1</span>),内嵌对象名n(内嵌对象参数表n)</div><div class="line">&#123;&#125;</div></pre></td></tr></table></figure>
<p>在定义派生类对象时，构造函数的执行顺序如下：<br>调用基类的构造函数；<br>调用内嵌对象成员（子对象类）的构造函数（有多个对象成员时，调用顺序由它们在类中声明的顺序确定）；<br>派生类中的构造函数体中的内容<br>撤销对象时，析构函数的调用顺序与构造函数的调用顺序相反。</p>
<p>当基类构造函数不带参数时，派生类可不定义构造函数，但基类构造函数带有参数，则派生类必须定义构造函数。<br>若基类使用缺省构造函数或不带参数的构造函数，则在派生类中定义构造函数时可略去<code>:基类构造函数名(参数表)</code><br>如果派生类的基类也是一个派生类，每个派生类只需负责其直接基类的构造，依次上溯。<br>由于析构函数是不带参数的，在派生类中是否定义析构函数与它所属的基类无关，基类的析构函数不会因为派生类没有析构函数而得不到执行，基类和派生类的析构函数是各自独立的。</p>
<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>派生类只有一个基类，这种派生方法称为单基派生或单继承<br>当一个派生类具有多个基类时，这种派生方法称为多基派生或多继承<br><code>class 派生类名:继承方式1 基类名1,...,继承方式n,基类名n {}</code></p>
<p>构造函数的执行顺序同单继承：<br>先执行基类构造函数，再执行对象成员的构造函数，最后执行派生类构造函数。<br>必须同时负责该派生类所有基类构造函数的调用。派生类的参数个数必须包含完成所有基类初始化所需的参数个数。<br>处于同一层次各基类构造函数执行顺序，取决于声明派生类时所制定各基类的顺序，与派生类构造函数中所定义的成员初始化列表的各项顺序无关。</p>
<p>对基类成员的访问必须是无二义性，使用类名限定可以消除二义性。</p>
<h4 id="虚基类"><a href="#虚基类" class="headerlink" title="虚基类"></a>虚基类</h4><p>当某一个类的多个直接基类是从另一个共同基类派生而来时，这些直接基类中从上一级基类继承来的成员就拥有相同的名称。在派生类的对象中，这些同名成员在内存中同时拥有多个拷贝。一种分辨方法是使用作用域标示符来唯一表示它们。另一种方法就是定义<strong>派生类</strong>，使派生类中只保留一份拷贝。<br><code>class 派生类名:virtual 继承方式 类名 {}</code></p>
<p>如果在虚基类中定义有带形参的构造函数，并且没有定义缺省形参的构造函数，则整个继承结构中，所有直接或间接的派生类都必须在构造函数的成员初始化表中列出对虚基类构造函数的调用，以初始化在虚基类中定义的数据成员。<br>建立一个对象时，如果这个对象中含有从虚基类继承来的成员，则虚基类的成员是由最远派生类的构造函数通过调用虚基类的构造函数进行初始化的。该派生类的其他基类对虚基类构造函数的调用都自动被忽略。<br>若同一层次中同时包含虚基类和非虚基类，应先调用虚基类的构造函数，再调用非虚基类的构造函数，最后调用派生类的构造函数。<br>对于多个虚基类，构造函数的执行顺序仍然是先左后右，自上而下。<br>对于非虚基类，构造函数的执行顺序仍然是先左后右，自上而下。<br>若虚基类由非虚基类派生而来，则仍然先调用基类构造函数，再调用派生类的构造函数。</p>
<h3 id="赋值兼容规则"><a href="#赋值兼容规则" class="headerlink" title="赋值兼容规则"></a>赋值兼容规则</h3><p>所谓赋值兼容规则是指在需要基类对象的任何地方都可以使用<strong>公有派生类</strong>的对象来替代。这样，公有派生类实际上具备了基类的所有特性，凡基类能解决的问题，公有派生类也能解决。（在公有派生已提及）</p>
<p>(1)可以用派生类对象给基类对象赋值。<br>(2)可以用派生类对象来初始化基类的引用。<br>(3)可以把派生类的地址赋值给指向基类的指针。（这种形式的转换，是在实际应用中最常见到的）<br>(4)可以把指向派生类对象的指针赋值给指向基类对象的指针</p>
<p>说明<br>(1)声明为指向基类对象的指针可以指向它的公有派生的对象，但不允许指向它的私有派生的对象<br>(2)允许将一个声明为指向基类的指针指向其公有派生类的对象，但是不能将一个声明为指向派生类对象的指针指向其基类的一个对象<br>(3)声明为指向基类对象的指针，当其指向公有派生类对象时，只能用它来直接访问派生类中从基类继承来的成员，而不能直接访问公有派生类中定义的成员。<br>若想访问其公有派生类的特定成员，可以将基类指针用显示类型转换为派生类指针。</p>
<h2 id="Lecture-5-多态性与虚函数"><a href="#Lecture-5-多态性与虚函数" class="headerlink" title="Lecture 5 多态性与虚函数"></a>Lecture 5 多态性与虚函数</h2><h3 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h3><p>所谓多态性就是不同对象收到相同的消息时，产生不同的动作。<br>C++中的多态性：<br>通用多态：参数多态，包含多态<br>专用多态：重载多态，强制多态<br><strong>参数多态</strong>与类属函数和类属类相关联，函数模板和类模板就是这种多态<br><strong>包含多态</strong>是研究类族中定义于不同类中的同名成员函数的多态行为，主要是通过虚函数来实现的<br><strong>重载多态</strong>如函数重载、运算符重载等。普通函数及类的成员函数的重载多属于重载多态<br><strong>强制多态</strong>是指将一个变元的类型加以变化，以符合一个函数或操作的要求，例如加法运算符在进行浮点数与整型数相加时，首先进行类型强制转换，把整型数变为浮点数再相加的情况，就是强制多态的实例</p>
<p>在C++中，<strong>编译时多态性</strong>主要是通过函数重载和运算符重载实现的，<strong>运行时多态性</strong>主要是通过虚函数来实现的</p>
<h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>虚函数允许函数调用与函数体之间的联系在运行时才建立，也就是在运行时才决定如何动作，即所谓的动态联编。<br>虚函数是成员函数，而且是非static的成员函数。是动态联编的基础。<br><code>virtual &lt;类型说明符&gt;&lt;函数名&gt;(&lt;参数表&gt;)</code><br>如果某类中的一个成员函数被说明为虚函数，这就意味着该成员函数在派生类中可能有不同的实现。当使用这个成员函数操作指针或引用所标识对象时，对该成员函数调用采取动态联编方式，即在运行时进行关联或束定。<br>动态联编只能通过指针或引用标识对象来操作虚函数。如果采用一般类型的标识对象来操作虚函数，则将采用静态联编方式调用虚函数。</p>
<p>派生类中对基类的虚函数进行替换时，要求派生类中说明的虚函数与基类中的被替换的虚函数之间满足如下条件：<br>(1)与基类的虚函数有相同的参数个数<br>(2)其参数的类型与基类的虚函数的对应参数类型相同<br>(3)其返回值或者与基类虚函数的相同,或者都返回指针或引用,并且派生类虚函数所返回的指针或引用的基类型是基类中被替换的虚函数所返回的指针或引用的基类型的子类型</p>
<p><strong>虚函数的作用</strong><br>虚函数同派生类的结合可使C++支持运行时的多态性,实现了在基类定义派生类所拥有的通用接口,而在派生类定义具体的实现方法,即常说的”同一接口,多种方法”,它帮助程序员处理越来越复杂的程序</p>
<p><strong>虚函数的定义</strong><br><code>virtual 函数类型 函数名(形参表){}</code><br>派生类中重新定义时,其函数原型,包括返回类型、函数名、参数个数、参数类型的顺序，都必须与其基类中的原型完全相同。</p>
<p>C++规定，如果在派生类中，没有用virtual显示地给出虚函数声明，这时系统就会遵循以下的规则来判断一个成员函数是不是虚函数：<br>·该函数与基类的虚函数有相同的名称<br>·该函数与基类的虚函数有相同的参数个数及相同的对应参数类型<br>·该函数与基类的虚函数有相同的返回类型或满足赋值兼容规则的指针、引用型的返回类型<br>派生类的函数满足了上述条件，就被自动确定为虚函数</p>
<p>说明：<br>(1)通过定义虚函数来使用C++提供的多态机制时，派生类应该从它的基类<strong>公有派生</strong>。赋值兼容规则成立的条件是派生类从其基类公有派生。<br>(2)必须首先在基类中定义虚函数。在实际应用中，应该在类等级内需要具有动态多态性的几个层次中的最高层类内首先声明虚函数。<br>(3)在派生类对基类中声明的虚函数进行重新定义时，关键字virtual可以写或不写。<br>(4)使用对象名和点运算符的方式也能调用虚函数，但是这种调用在编译时进行的是静态联编，它没有充分利用虚函数的特性。只有通过基类指针访问虚函数时才能获得运行时的多态性。<br>(5)一个虚函数无论被公有继承多少次，它仍然保持其虚函数的特性。<br>(6)虚函数必须是其所在类的成员函数，而不能是友元函数，也不能是静态成员函数，因为虚函数调用要靠特定的对象来决定该激活哪个函数。但是虚函数可以在另一个类中被声明为友元函数。<br>(7)内联函数不能是虚函数，因为内联函数是不能在运行中动态确定其位置的。即使虚函数在类的内部定义，编译时仍将其看作是非内联的。<br>(8)构造函数不能是虚函数。因为虚函数作为运行过程中多态的基础，主要是针对对象的，而构造函数是在产生对象之前运行的，因此虚构造函数是没有意义的。<br>(9)析构函数可以是虚函数，而且通常声明为虚函数。</p>
<p><strong>虚析构函数</strong><br>在程序用带指针参数的delete运算符撤销对象时，会发生一种情况：系统会只执行基类的析构函数，而不执行派生类的析构函数。<br>解决方法：将基类的析构函数声明为虚函数<br>析构函数设置为虚函数后，在使用指针引用时可以动态联编，实现运行时的多态，保证使用基类类型的指针能够调用适当的析构函数针对不同的对象进行清理工作</p>
<p>虚函数与重载函数的关系<br>在一个派生类中重新定义基类的虚函数是函数重载的另一种形式，但它不同于一般的函数重载。<br>普通的函数重载时，其函数的参数个数或参数类型必须有所不同，函数的返回类型也可以不同。<br>当重载一个虚函数时，也就是说在派生类中重新定义虚函数时，要求函数名、返回类型、参数个数、参数的类型和顺序与基类中的虚函数原型完全相同。<br>若仅仅函数名相同，而参数的个数、类型或顺序不同，系统将它作为普通的函数重载，这时将失去虚函数的特性。</p>
<h3 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h3><h4 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h4><p><strong>纯虚函数</strong>是一个在基类中说明的虚函数，它在基类中没有定义，但要求在它的派生类中必须定义自己的版本，或重新说明为纯虚函数。<br><code>virtual &lt;函数类型&gt;&lt;函数名&gt;(参数表)=0;</code><br>纯虚函数与一般虚函数成员的原型在书写形式上的不同就在于后面加了<code>=0</code>，表明在基类中不用定义该函数，它的实现部分（函数体）留给派生类去做。</p>
<p>纯虚函数没有函数体<br>最后面的<code>=0</code>并不表示函数返回值为0<br>这是一个声明语句，最后有<code>;</code><br>纯虚函数只有函数的名字而不具备函数的功能，不能被调用。在派生类中对此函数提供定义后，它才能具备函数的功能，可被调用。<br>如果在一个类中声明了纯虚函数，而在其派生类中没有对该函数定义，则该虚函数在派生类中仍然为纯虚函数。<br>一个具有纯虚函数的类称为<strong>抽象类</strong></p>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>如果一个类至少有一个纯虚函数，那么就称该类为抽象类。<br>抽象类只能作为其他类的基类来使用，不能建立抽象类对象，其纯虚函数的实现由派生类给出。<br>派生类中必须重载基类中的纯虚函数，否则它仍将被看作一个抽象类。</p>
<p>规定：<br>(1)由于抽象类中至少包含一个没有定义功能的纯虚函数，因此，抽象类只能作为其他类的基类来使用，不能建立抽象类的对象，纯虚函数的实现由派生类给出<br>(2)不允许从具体类派生出抽象类<br>(3)抽象类不能用作参数类型、函数返回类型或显示转换的类型<br>(4)可以声明指向抽象类的指针或引用，此指针可以指向它的派生类，进而实现多态性<br>(5)抽象类的析构函数可以被声明为纯虚函数，这时，应该至少提供该析构函数的一个实现<br>(6)如果派生类中没有重定义纯虚函数，而派生类只是继承基类的纯虚函数，则这个派生类仍然是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不是抽象类了，它是一个可以建立对象的具体类<br>(7)在抽象类中也可以定义普通成员函数或虚函数，虽然不能为抽象类声明对象，但仍然可以通过派生类对象来调用这些不是纯虚函数的函数。</p>
<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>运算符重载是使同一个运算符作用于不同类型的数据时具有不同的行为。运算符重载实质上将运算对象转化为运算函数的实参，并根据实参的类型来确定重载的运算函数。</p>
<p>运算符重载的规则<br>1.只能重载C++中已有的运算符，不能臆造新的运算符<br>2.类属关系运算符<code>.</code>、作用域分辨符<code>::</code>、成员指针运算符<code>*</code>、<code>sizeof</code>运算符和三目运算符<code>?:</code>不能重载<br>3.重载之后运算符的优先级和结合性都不能改变，单目运算符只能重载为单目运算符，双目运算符只能重载为双目运算符<br>4.运算符重载后的功能应当与原有功能相类似<br>5.重载运算符含义必须清楚，不能有二义性</p>
<h4 id="将运算符重载为类的成员函数"><a href="#将运算符重载为类的成员函数" class="headerlink" title="将运算符重载为类的成员函数"></a>将运算符重载为类的成员函数</h4><p>将运算符重载为类的成员函数就是在类中用关键字operator定义一个成员函数，函数名就是重载的运算符。运算符如果重载为类的成员函数，它就可以自由地访问该类的数据成员。<br><code>&lt;类型&gt;&lt;类名&gt;::operator&lt;要重载的运算符&gt;(形参表){}</code></p>
<p><strong>双目运算</strong><br>op1 B op2<br>把B重载为op1所属类的成员函数，只有一个形参，形参的类型是op2所属类。<br>例如，经过重载后，<code>op1+op2</code>就相当于<code>op1.operator+(op2)</code></p>
<p><strong>单目运算</strong><br>(1)前置单目运算：U op<br>把U重载为operand所属类的成员函数，没有形参。<br>例如，<code>++</code>重载的语法格式为:<code>&lt;函数类型&gt; operator ++();</code><br><code>++op</code>就相当于函数调用<code>op.operator ++();</code></p>
<p>(2)后置单目运算：op V<br>运算符V重载为op所属类的成员函数，带有一个整型(int)形参。<br>例如，后置单目运算符<code>--</code>重载的语法格式为:<code>&lt;函数类型&gt; operator --(int);</code><br><code>op--</code>就相当于函数调用<code>op.operator--(0);</code></p>
<p>对于++(—)运算符的重载，因为编译器不能区分出++(—)是前置还是后置的，所以要加上(int)来区分。</p>
<p><strong>赋值运算</strong><br>赋值运算符重载一般包括以下几个步骤，首先要检查是否自赋值，如果是要立即返回，如果不返回，后面的语句会把自己所指空间删掉，从而导致错误；第二步要释放原有的内存资源；第三步要分配新的内存资源，并复制内容；第四步是返回本对象的引用。如果没有指针操作，则没有第二步操作。<br>赋值运算符与拷贝构造函数在功能上有些类似，都是用一个对象去填另一个对象，但拷贝构造函数是在对象建立的时候执行，赋值运算符是在对象建立之后执行。</p>
<h4 id="运算符重载为友元函数"><a href="#运算符重载为友元函数" class="headerlink" title="运算符重载为友元函数"></a>运算符重载为友元函数</h4><p><code>friend &lt;函数返回类型&gt; operator &lt;二元运算符&gt;(&lt;形参1&gt;,&lt;形参2&gt;);</code><br><code>friend &lt;函数返回类型&gt; operator &lt;一元运算符&gt;(类名 &amp;对象){}</code></p>
<p>其中，函数返回类型为运算符重载函数的返回类型。<code>operator&lt;重载函数符&gt;</code>为重载函数名。当重载函数作为友元普通函数时，重载函数不能用对象调用，所以参加运算的对象必须以形参方式传送到重载函数体内，在二元运算符重载函数为友元函数时，形参通常为两个参加运算的对象。</p>
<p><strong>双目运算</strong><br>op1 B op2<br>双目运算符B重载为op1所属类的友元函数，该函数有两个形参，表达式<code>op1 B op2</code>相当于函数调用<code>operator B(op1, op2)</code></p>
<p><strong>单目运算</strong><br>(1)前置单目运算 U op<br>前置单目运算符U重载为op所属类的友元函数，表达式<code>U op</code>相当于函数调用<code>operator U(op)</code></p>
<p>(2)后置单目运算 op U<br>后置单目运算符V重载为op所属类的友元函数，表达式<code>op V</code>相当于函数调用<code>operator V(op, int)</code></p>
<h3 id="重载流插入和流提取运算符"><a href="#重载流插入和流提取运算符" class="headerlink" title="重载流插入和流提取运算符"></a>重载流插入和流提取运算符</h3><p>istream和ostream是C++的预定义流类，cin是istream的对象，cout是ostream的对象。运算符&lt;&lt;由ostream重载为插入操作，运算符&gt;&gt;由istream重载为提取操作，用于输入和输出基本类型数据。可用重载&lt;&lt;和&gt;&gt;运算符，用于输入和输出用户自定义的数据类型，必须定义为类的友元函数。</p>
<h4 id="输出操作符的重载"><a href="#输出操作符的重载" class="headerlink" title="输出操作符的重载"></a>输出操作符的重载</h4><p><code>ostream &amp; operator &lt;&lt;(ostream &amp;, const 自定义类&amp;);</code><br>第一个参数和函数的类型都必须是<code>ostream &amp;</code>类型，第二个参数是对要进行输出的类类型的引用，它可以是const，因为一般而言输出一个对象不应该改变对象。返回类型是一个ostream引用，通常是输出操作符所操作的ostream对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;output,Date &amp;d)</div><div class="line">&#123;</div><div class="line">    output&lt;&lt;d.year&lt;&lt;“-”&lt;&lt;d.month&lt;&lt;“-”&lt;&lt;d.day；</div><div class="line">    <span class="keyword">return</span> output;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="输入操作符的重载"><a href="#输入操作符的重载" class="headerlink" title="输入操作符的重载"></a>输入操作符的重载</h4><p><code>istream &amp; operator &gt;&gt;(istream &amp;, 自定义类 &amp;)</code><br>与输出操作符类似，输入操作符的第一个形参是一个引用，指向要读的流，并且返回的也是同一个流的引用。第二个形参是对要读入的对象的非const引用，该形参必须为非const，因为输入操作符的目的是将数据读到这个对象中。和输出操作符不同的是输入操作符必须处理错误和文件结束的可能性。</p>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:</strong>
    Hael Chan
  </li>
  <li class="post-copyright-link">
    <strong>Post link:</strong>
    <a href="http://haelchan.me/2018/03/14/oop-note/" title="面向对象程序设计课堂笔记">http://haelchan.me/2018/03/14/oop-note/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice: </strong>
    All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> unless stating additionally.
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/learning-note/" rel="tag"># learning note</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/02/18/deep-learning-note/" rel="next" title="deep-learning-note">
                <i class="fa fa-chevron-left"></i> deep-learning-note
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/03/31/NLP-note/" rel="prev" title="COMS W4705 Natural Language Processing Note">
                COMS W4705 Natural Language Processing Note <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>
  


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Hael Chan" />
            
              <p class="site-author-name" itemprop="name">Hael Chan</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/haelchan" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:f.procumbens@gmail.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://twitter.com/Procumbens" target="_blank" title="Twitter">
                    
                      <i class="fa fa-fw fa-twitter"></i>Twitter</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.zhihu.com/people/hael-c/activities" target="_blank" title="知乎">
                    
                      <i class="fa fa-fw fa-compass"></i>知乎</a>
                </span>
              
            
          </div>

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-globe"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://learnerwn.github.io" title="WN_Blog" target="_blank">WN_Blog</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://hey-yahei.cn" title="YaHei" target="_blank">YaHei</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://ruder.io" title="Sebastian Ruder" target="_blank">Sebastian Ruder</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://godweiyang.com" title="WeiYang Blog" target="_blank">WeiYang Blog</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.linzehui.me" title="Weekly Review" target="_blank">Weekly Review</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Lecture-1-绪论"><span class="nav-number">1.</span> <span class="nav-text">Lecture 1 绪论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#序"><span class="nav-number">1.1.</span> <span class="nav-text">序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本概念"><span class="nav-number">1.2.</span> <span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对象"><span class="nav-number">1.2.1.</span> <span class="nav-text">对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类"><span class="nav-number">1.2.2.</span> <span class="nav-text">类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#消息"><span class="nav-number">1.2.3.</span> <span class="nav-text">消息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法"><span class="nav-number">1.2.4.</span> <span class="nav-text">方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面向对象程序设计的基本特征"><span class="nav-number">1.3.</span> <span class="nav-text">面向对象程序设计的基本特征</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#抽象"><span class="nav-number">1.3.1.</span> <span class="nav-text">抽象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#封装"><span class="nav-number">1.3.2.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#继承"><span class="nav-number">1.3.3.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多态"><span class="nav-number">1.3.4.</span> <span class="nav-text">多态</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-对C的补充"><span class="nav-number">1.4.</span> <span class="nav-text">C++对C的补充</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#注释与续行"><span class="nav-number">1.4.1.</span> <span class="nav-text">注释与续行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#输入输出流"><span class="nav-number">1.4.2.</span> <span class="nav-text">输入输出流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#灵活的变量说明"><span class="nav-number">1.4.3.</span> <span class="nav-text">灵活的变量说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#结构、联合和枚举名"><span class="nav-number">1.4.4.</span> <span class="nav-text">结构、联合和枚举名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数原型"><span class="nav-number">1.4.5.</span> <span class="nav-text">函数原型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#const修饰符"><span class="nav-number">1.4.6.</span> <span class="nav-text">const修饰符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#void型指针"><span class="nav-number">1.4.7.</span> <span class="nav-text">void型指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内联函数"><span class="nav-number">1.4.8.</span> <span class="nav-text">内联函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#带有缺省参数值的函数"><span class="nav-number">1.4.9.</span> <span class="nav-text">带有缺省参数值的函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数重载"><span class="nav-number">1.4.10.</span> <span class="nav-text">函数重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#作用域标识符"><span class="nav-number">1.4.11.</span> <span class="nav-text">作用域标识符::</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#无名联合"><span class="nav-number">1.4.12.</span> <span class="nav-text">无名联合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#强制类型转换"><span class="nav-number">1.4.13.</span> <span class="nav-text">强制类型转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态内存分配"><span class="nav-number">1.4.14.</span> <span class="nav-text">动态内存分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#引用"><span class="nav-number">1.4.15.</span> <span class="nav-text">引用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lecture-2-类和对象"><span class="nav-number">2.</span> <span class="nav-text">Lecture 2 类和对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类的构成"><span class="nav-number">2.1.</span> <span class="nav-text">类的构成</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#private-protected-public"><span class="nav-number">2.1.1.</span> <span class="nav-text">private, protected, public</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#成员函数的声明"><span class="nav-number">2.2.</span> <span class="nav-text">成员函数的声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象的定义和使用"><span class="nav-number">2.3.</span> <span class="nav-text">对象的定义和使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数与析构函数"><span class="nav-number">2.4.</span> <span class="nav-text">构造函数与析构函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#构造函数"><span class="nav-number">2.4.1.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#成员初始化表"><span class="nav-number">2.4.2.</span> <span class="nav-text">成员初始化表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#拷贝构造函数"><span class="nav-number">2.4.3.</span> <span class="nav-text">拷贝构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#析构函数"><span class="nav-number">2.4.4.</span> <span class="nav-text">析构函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#调用构造函数和析构函数的顺序"><span class="nav-number">2.4.5.</span> <span class="nav-text">调用构造函数和析构函数的顺序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lecture-3-类和对象"><span class="nav-number">3.</span> <span class="nav-text">Lecture 3 类和对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#自引用指针this"><span class="nav-number">3.1.</span> <span class="nav-text">自引用指针this</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象数组与对象指针"><span class="nav-number">3.2.</span> <span class="nav-text">对象数组与对象指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对象数组"><span class="nav-number">3.2.1.</span> <span class="nav-text">对象数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象指针"><span class="nav-number">3.2.2.</span> <span class="nav-text">对象指针</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#向函数传递对象"><span class="nav-number">3.3.</span> <span class="nav-text">向函数传递对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态成员"><span class="nav-number">3.4.</span> <span class="nav-text">静态成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#友元"><span class="nav-number">3.5.</span> <span class="nav-text">友元</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#友元函数"><span class="nav-number">3.5.1.</span> <span class="nav-text">友元函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#友元成员函数"><span class="nav-number">3.5.2.</span> <span class="nav-text">友元成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#友元类"><span class="nav-number">3.5.3.</span> <span class="nav-text">友元类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#共用数据的保护-const"><span class="nav-number">3.6.</span> <span class="nav-text">共用数据的保护(const)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#常数据成员"><span class="nav-number">3.6.1.</span> <span class="nav-text">常数据成员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常成员函数"><span class="nav-number">3.6.2.</span> <span class="nav-text">常成员函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指向常对象的指针变量"><span class="nav-number">3.7.</span> <span class="nav-text">指向常对象的指针变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lecture-4-派生类与继承"><span class="nav-number">4.</span> <span class="nav-text">Lecture 4 派生类与继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#继承与派生类"><span class="nav-number">4.1.</span> <span class="nav-text">继承与派生类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#继承的访问控制"><span class="nav-number">4.1.1.</span> <span class="nav-text">继承的访问控制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#派生类的构造函数和析构函数"><span class="nav-number">4.2.</span> <span class="nav-text">派生类的构造函数和析构函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多继承"><span class="nav-number">4.3.</span> <span class="nav-text">多继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#虚基类"><span class="nav-number">4.3.1.</span> <span class="nav-text">虚基类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#赋值兼容规则"><span class="nav-number">4.4.</span> <span class="nav-text">赋值兼容规则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lecture-5-多态性与虚函数"><span class="nav-number">5.</span> <span class="nav-text">Lecture 5 多态性与虚函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#多态性"><span class="nav-number">5.1.</span> <span class="nav-text">多态性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚函数"><span class="nav-number">5.2.</span> <span class="nav-text">虚函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#纯虚函数和抽象类"><span class="nav-number">5.3.</span> <span class="nav-text">纯虚函数和抽象类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#纯虚函数"><span class="nav-number">5.3.1.</span> <span class="nav-text">纯虚函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#抽象类"><span class="nav-number">5.3.2.</span> <span class="nav-text">抽象类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运算符重载"><span class="nav-number">5.4.</span> <span class="nav-text">运算符重载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#将运算符重载为类的成员函数"><span class="nav-number">5.4.1.</span> <span class="nav-text">将运算符重载为类的成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#运算符重载为友元函数"><span class="nav-number">5.4.2.</span> <span class="nav-text">运算符重载为友元函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重载流插入和流提取运算符"><span class="nav-number">5.5.</span> <span class="nav-text">重载流插入和流提取运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#输出操作符的重载"><span class="nav-number">5.5.1.</span> <span class="nav-text">输出操作符的重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#输入操作符的重载"><span class="nav-number">5.5.2.</span> <span class="nav-text">输入操作符的重载</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hael Chan</span>

  
</div>









<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

<span id="busuanzi_container_site_uv">
  Welcome~ Thanks for visiting my blog.
  Visitors: <span id="busuanzi_value_site_uv"></span>
</span>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  

    
      <script id="dsq-count-scr" src="https://hael.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://haelchan.me/2018/03/14/oop-note/';
          this.page.identifier = '2018/03/14/oop-note/';
          this.page.title = '面向对象程序设计课堂笔记';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://hael.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'manual') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("3HhWLTewaKTSPj5DC3qp5b2m-gzGzoHsz", "zjxN2hpHQEmyMaz0XBicI3bn");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  


  

  

</body>
</html>
