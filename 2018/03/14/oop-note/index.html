<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="learning note," />










<meta name="description" content="Lecture 1序程序设计范型是指设计程序的规范、模型和风格，它是一类程序设计语言的基础。  面向过程程序设计范型：程序=过程+调用 或 程序=算法+数据结构 函数式程序设计范型：程序被看作“描述输入与输出之间关系”的数学函数。如LISP 面向对象程序设计是一种新型的程序设计范型。这种范型的主要特征是：对象=（算法+数据结构）程序=对象+消息  面向对象程序的主要结构特点：一、程序一般由类的定义">
<meta name="keywords" content="learning note">
<meta property="og:type" content="article">
<meta property="og:title" content="面向对象程序设计课堂笔记">
<meta property="og:url" content="http://haelchan.me/2018/03/14/oop-note/index.html">
<meta property="og:site_name" content="Hael&#39;s Blog">
<meta property="og:description" content="Lecture 1序程序设计范型是指设计程序的规范、模型和风格，它是一类程序设计语言的基础。  面向过程程序设计范型：程序=过程+调用 或 程序=算法+数据结构 函数式程序设计范型：程序被看作“描述输入与输出之间关系”的数学函数。如LISP 面向对象程序设计是一种新型的程序设计范型。这种范型的主要特征是：对象=（算法+数据结构）程序=对象+消息  面向对象程序的主要结构特点：一、程序一般由类的定义">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-04-24T07:46:58.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面向对象程序设计课堂笔记">
<meta name="twitter:description" content="Lecture 1序程序设计范型是指设计程序的规范、模型和风格，它是一类程序设计语言的基础。  面向过程程序设计范型：程序=过程+调用 或 程序=算法+数据结构 函数式程序设计范型：程序被看作“描述输入与输出之间关系”的数学函数。如LISP 面向对象程序设计是一种新型的程序设计范型。这种范型的主要特征是：对象=（算法+数据结构）程序=对象+消息  面向对象程序的主要结构特点：一、程序一般由类的定义">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://haelchan.me/2018/03/14/oop-note/"/>





  <title>面向对象程序设计课堂笔记 | Hael's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hael's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://haelchan.me/2018/03/14/oop-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hael Chan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hael's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">面向对象程序设计课堂笔记</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-14T16:50:12+08:00">
                2018-03-14
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2018-04-24T15:46:58+08:00">
                2018-04-24
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/03/14/oop-note/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/03/14/oop-note/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2018/03/14/oop-note/" class="leancloud_visitors" data-flag-title="面向对象程序设计课堂笔记">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Lecture-1"><a href="#Lecture-1" class="headerlink" title="Lecture 1"></a>Lecture 1</h2><h3 id="序"><a href="#序" class="headerlink" title="序"></a>序</h3><p>程序设计范型是指设计程序的规范、模型和风格，它是一类程序设计语言的基础。</p>
<ul>
<li><strong>面向过程</strong>程序设计范型：程序=过程+调用 或 程序=算法+数据结构</li>
<li><strong>函数式</strong>程序设计范型：程序被看作“描述输入与输出之间关系”的数学函数。如LISP</li>
<li><strong>面向对象</strong>程序设计是一种新型的程序设计范型。这种范型的主要特征是：对象=（算法+数据结构）程序=对象+消息</li>
</ul>
<p>面向对象程序的主要结构特点：<br>一、程序一般由<strong>类的定义</strong>和<strong>类的使用</strong>两部分组成，在主程序中定义各对象并规定它们之间传递消息的规律。<br>二、程序中的一切操作都是通过<strong>向对象发送消息</strong>来实现的，对象接收到消息后，启动有关方法完成相应的操作。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>对象 Object</li>
<li>类 Class</li>
<li>消息 Message</li>
<li>方法 Method</li>
</ul>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>在现实世界中，任何事物都是对象。可以使有形的具体存在的事物，也可以是无形的抽象的事件。<br>对象一般可以表示为：<strong>属性+行为</strong><br>（单独的可以缺属性只定义行为，整个体系则缺一不可）</p>
<p><strong>名字</strong>：用于区别不同的实体<br><strong>属性/状态</strong>：属性用于描述不同实体的特征状态由这个对象的属性和这些属性的当前值决定。<br><strong>操作</strong>：用于描述不同实体可具有的行为是对象提供给用户的一种服务，也叫行为或方法。<br>· 对象的操作可以分为两类，一类是<strong>自身所承受</strong>的操作(private/protected)，一类是<strong>施加于其他对象</strong>的操作(public)。</p>
<p>方法(Method)——就是对象所能执行的操作，即服务。方法描述了对象执行操作的算法，响应消息的方法。在C++中称为<strong>成员函数</strong>。<br>属性(Attribute)——就是类中所定义的数据，它是对客观世界实体所具有性质的抽象。C++中称为<strong>数据成员</strong>。</p>
<p>在面向对象程序设计中，对象是描述其属性的<strong>数据</strong>及对这些数据施加的一组<strong>操作</strong>封装在一起构成的<strong>统一体</strong>。<br>对象可以认为是：<strong>数据+方法（操作）</strong></p>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>在现实世界中，<strong>类</strong>是一组具有相同<strong>属性</strong>和<strong>行为</strong>的对象的抽象。<br><strong>类</strong>和<strong>对象</strong>之间的关系式<strong>抽象</strong>和<strong>具体</strong>的关系。类是多个对象进行综合抽象的结果，一个对象是类的一个实例。<br>在面向对象程序设计中，类就是<strong>具有相同数据和相同操作的一组对象的集合</strong>。是对具有相同数据结构和相同操作的一类对象的描述。<br>在面向对象程序设计中，总是先声明类，再由类生成其对象。</p>
<p>注意不能把一组函数组合在一起构成类。即类不是函数的集合。</p>
<h4 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h4><p>面向对象设计技术必须提供一种机制允许一个对象与另一个对象的交互，这种机制叫<strong>消息传递</strong>。<br>在面向对象程序设计中，一个对象向另一个对象发出的<strong>请求</strong>被称为<strong>消息</strong>。当对象收到消息时，就调用有关的方法，执行相应的操作。<strong>消息是一个对象要求另一个对象执行某个操作的规格说明</strong>，通过消息传递才能完成对象之间的相互请求或相互协作。<br>消息具有三个性质：<br>(1).同一个对象可以接收不同形式的多个消息，作出不同的响应<br>(2).相同形式的消息可以传递给不同的对象，所作出的响应可以是不同的。<br>(3).对消息的响应并不是必需的，对象可以响应消息，也可以不响应。<br>分为两类：<strong>公有消息</strong>（其他对象发出），<strong>私有消息</strong>（向自己发出）。</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>方法就是对象所能执行的操作。方法包括界面和方法体两部分。<br>方法的<strong>界面</strong>就是消息的模式，它给出了方法调用的协议；<br><strong>方法体</strong>则是实现某种操作的一系列计算步骤，就是一段程序<br>在C++语言中方法是通过函数来实现的，称为<strong>成员函数</strong><br><strong>消息和方法的关系</strong>是：对象根据接收到的消息，调用相应的方法；反过来，有了方法，对象才能响应相应的消息。</p>
<h3 id="面向对象程序设计的基本特征"><a href="#面向对象程序设计的基本特征" class="headerlink" title="面向对象程序设计的基本特征"></a>面向对象程序设计的基本特征</h3><ul>
<li>抽象 Abstraction</li>
<li>封装 Encapsulation</li>
<li>继承 Inheritance</li>
<li>多态 Polymorphism</li>
</ul>
<h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><p>抽象是通过特定的实例（对象）抽取<strong>共同性质</strong>以后形成概念的过程。抽象是对系统的简化描述和规范说明，他强调了系统中的一部分细节和特性，而<strong>忽略了其他部分</strong>。<br>抽象包括两个方面，<strong>数据抽象</strong>和<strong>代码抽象</strong>（或称行为抽象）。前者描述某类对象的属性和状况，也就是此类对象区别于彼类对象的特征物理量；后者描述了某类对象的共同行为特征或具有的共同操作。<br>在面向对象的程序设计方法中，对一个具体问题的抽象分析结果，是通过<strong>类</strong>来<strong>描述和实现</strong>的。</p>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>在面向对象程序设计中，封装是指<strong>把数据和实现操作的代码</strong>集中起来放在对象内部，并尽可能隐藏对象的内部细节。<br>封装应该具有如下几个条件：<br>（1）对象具有一个清晰的边界，对象的私有数据和实现操作的代码被封装在该边界内。<br>（2）具有一个描述对象与其他对象如何相互作用的接口，该接口必须说明消息如何传递的使用方法。<br>（3）对象内部的代码和数据应受到保护，其他对象不能直接修改。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>继承是在一个已经建立的类的基础上再接着声明一个新类的扩展机制，原先已经建立的类称为<strong>基类</strong>，在基类之下扩展的类称为<strong>派生类</strong>，派生类又可以向下充当继续扩展的基类，因此构成层层派生的一个动态扩展过程。<br>派生类享有基类的数据结构和算法，而本身又具有增加的行为和特性，因此继承的机制促进了程序代码的可重用性。<br>一个基类可以有多个派生类，一个派生类反过来可以具有多个基类，形成复杂的继承树<strong>层次体系</strong>。</p>
<p>基类与派生类之间本质的关系：基类是一个简单的类，描述相对简单的事物，派生类是一个复杂些的类，处理相对复杂的现象。</p>
<p>继承的作用：<br>避免公用代码的重复开发，减少代码和数据冗余。<br>通过增强一致性来减少模块间的接口。<br>继承分为单继承和多继承。</p>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态性是指<strong>不同的对象收到相同的消息时产生多种不同的行为方式</strong>。<br>C++支持两种多态性：编译时的多态性（重载）和运行时的多态性（虚函数）。</p>
<p><strong>为什么要使用OOP</strong><br>传统程序设计方法的局限性<br>（1）传统程序设计开发软件的生产效率低下<br>存在<strong>重用性</strong>、<strong>复杂性</strong>和<strong>可维护</strong>问题。(OOP三大优势)<br>（2）传统程序设计难以应付日益庞大的信息量和多样的信息类型<br>当代计算机所处理的数据已从最简单的数据和字符发展为多种格式的多媒体数据，如文本、图形、图像、影像、声音等。面对庞大的信息量和多样的信息格式，传统程序设计无法应付。<br>（3）传统的程序设计<strong>难以适应</strong>各种<strong>新环境</strong><br>并行处理、分布式、网络和多机系统等<strong>节点之间的通信机制</strong>传统的程序设计技术很难处理。</p>
<p><strong>OOP的主要优点</strong><br>（1）可提高程序的重用性<br>（2）可控制程序的复杂性<br>（3）可改善程序的可维护性<br>（4）能够更好地支持大型程序设计<br>（5）增强了计算机处理信息的范围<br>（6）能很好地适应新的硬件环境</p>
<p><strong>C++的优点</strong><br>C++继承了C的优点，并有自己的特点，主要有：<br>（1）全面兼容C，C的许多代码不经修改就可以为C++所用，用C编写的库函数和实用软件可以用于C++。<br>（2）用C++编写的程序可读性更好，代码结构更为合理，可直接在程序中映射问题空间结构。<br>（3）生成代码的质量高，运行效率高。<br>（4）从开发时间、费用到形成软件的可重用性、可扩充性、可维护性和可靠性等方面有了很大提高，使得大中型的程序开发项目变得容易得多。<br>（5）支持面向对象的机制，可方便地构造出模拟现实问题的实体和操作。</p>
<h3 id="C-对C的补充"><a href="#C-对C的补充" class="headerlink" title="C++对C的补充"></a>C++对C的补充</h3><h4 id="注释与续行"><a href="#注释与续行" class="headerlink" title="注释与续行"></a>注释与续行</h4><p>注释符：<code>/* */</code>或<code>//</code><br>续行符：<code>\</code>。当一个语句太长时可以用该符号分段写在几行中<br>note: 其实不加续航符直接换行也可以0.0<br>E.g.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello "</span></div><div class="line">         &lt;&lt; <span class="string">"world"</span></div><div class="line">         &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div></pre></td></tr></table></figure>
<p>This program will print <code>hello world</code> in a line.</p>
<h4 id="输入输出流"><a href="#输入输出流" class="headerlink" title="输入输出流"></a>输入输出流</h4><p>C: <code>scanf</code>和<code>printf</code><br>C++: <code>cin&gt;&gt;</code>和<code>cout&lt;&lt;</code>（用C的也可以，但是不推荐……）<br>cout和cin分别是C++的标准输出流和输入流。C++支持重定向，但一般cout指的是屏幕，cin指的是键盘。操作符<code>&lt;&lt;</code>和<code>&gt;&gt;</code>除了具有C语言中定义的左移和右移的功能外，在这里符号<code>&lt;&lt;</code>是把右方的参数写到标准输出流cout中；相反，符号<code>&gt;&gt;</code>则是将标准输入流的数据赋给右方的变量。<br>cin和<code>&gt;&gt;</code>，cout和<code>&lt;&lt;</code>配套使用<br>使用cout和cin时，也可以对输入和输出的格式进行控制，比如可用不同的进制方式显示数据，只要设置转换基数的操作符dec、hex和oct即可。</p>
<h4 id="灵活的变量说明"><a href="#灵活的变量说明" class="headerlink" title="灵活的变量说明"></a>灵活的变量说明</h4><p>定义变量的位置<br>在程序中的不同位置采用不同的变量定义方式，决定了该变量具有不同的特点。变量的定义一般可由以下三种位置：<br>（1）函数体内部<br>在函数体内部定义的变量称为局部变量。<br>（2）形式参数<br>当定义一个有参函数时，函数名后面括号内的变量，统称为形式参数。<br>（3）全局变量：在所有函数体外部定义的变量，其作用范围是整个程序，并在整个程序运行期间有效。</p>
<p>在C语言中，全局变量声明必须在任何函数之前，局部变量必须集中在可执行语句之前。<br>C++中的变量声明非常灵活。它允许变量声明与可执行语句交替执行，随时声明。<code>for (int i = 0; i &lt; 10; i++)</code></p>
<h4 id="结构、联合和枚举名"><a href="#结构、联合和枚举名" class="headerlink" title="结构、联合和枚举名"></a>结构、联合和枚举名</h4><p>在C++中，结构名、联合名、枚举名都是类型名。在定义变量时，不必在结构名、联合名或枚举名前冠以struct、union或enum。<br>如：定义枚举类型<code>boole</code>: <code>enum boole{FALSE, TRUE};</code><br>在C语言中定义变量需写成<code>enum boole done;</code>，但在C++中，可以说明为<code>boole done;</code>。</p>
<h4 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h4><p>C语言<strong>建议</strong>编程者为程序中的每一个函数建立圆形，而C++<strong>要求</strong>为每一个函数建立原型，以说明函数的名称、参数类型与个数，以及函数返回值的类型。其主要目的是让C++编译程序进行类型检查，即形参与实参的类型匹配检查，以及返回值是否与原型相符，以维护程序的正确性。<br>在程序中，要求一个函数的原型出现在该函数的调用语句之前。说明：<br>（1）函数原型的参数表中<strong>可不包含参数的名字</strong>，而只包含它们的类型。例如<code>long Area(int, int);</code><br>（2）函数定义由函数首部和函数体构成。函数首部和函数原型基本一样，但函数首部中的参数必须给出名字而且不包含结尾的分号。<br>（3）C++的参数说明必须放在函数说明后的括号内，不可将函数参数说明放在函数首部和函数体之间。这种方法只在C中成立。<br>（4）主函数不必进行原型说明，因为它被看成自动说明原型的函数。<br>（5）原型说明中没有指定返回类型的函数（包括主函数main），C++默认该函数的返回类型是int。<br>（6）如果一个函数没有返回值，则必须在函数原型中注明返回类型为void，主函数类似处理。<br>（7）如果函数原型中未注明参数，C++假定该函数的参数表为空(void)。</p>
<h4 id="const修饰符"><a href="#const修饰符" class="headerlink" title="const修饰符"></a>const修饰符</h4><p>C语言中习惯用<code>#define</code>定义常量，C++利用const定义正规常数<br>一般格式 <code>const 数据类型标识符 常数名 = 常量值</code><br>采用这种方式定义的常量是类型化的，它有地址，可以用指针指向这个值，但不能修改它。<br>const必须放在被修饰类型符和类型名前面。<br>数据类型是可选项，用来指定常数值的数据类型，如果省略了数据类型，那么默认是int。<br>const的作用于<code>#define</code>相似，但它消除了<code>#define</code>的不安全性。</p>
<p>const可以与指针一起使用。<br>指向常量的指针、常指针和指向常量的常指针。<br>1）<strong>指向常量的指针</strong>是指：一个指向常量的指针变量。<br>2）<strong>常指针</strong>是指：把指针本身，而不是它指向的对象声明为常量。<br>3）<strong>指向常量的常指针</strong>是指：这个指针本身不能改变，它所指向的值也不能改变。要声明一个指向常量的常指针，二者都要声明为const。</p>
<p>说明：<br>（1）如果用const定义的是一个整型变量，关键词int<strong>可以省略</strong>。<br>（2）常量一旦被建立，在程序的任何地方都<strong>不能再更改</strong>。<br>（3）与<code>#define</code>定义的常量有所不同，const定义的常量可以<strong>有自己的数据类型</strong>，这样C++的编译程序可以进行更加严格的类型检查，具有良好的编译时的检测性。<br>（4）函数参数也可以用const说明，用于保证实参在该函数内部不被改动。</p>
<h4 id="void型指针"><a href="#void型指针" class="headerlink" title="void型指针"></a>void型指针</h4><p>void通常表示无值，但将void作为指针的类型时，它却表示<strong>不确定的类型</strong>。这种void型指针是一种通用型指针，也就是说任何类型的指针值都可以赋给void类型的指针变量。<br>void型指针可以接受任何类型的指针的赋值，但对已获值的void型指针，对它在进行处理，如输出或传递指针值时，则必须进行<strong>强制类型转换</strong>，否则会出错。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">void</span> *pc;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">456</span>;</div><div class="line">    <span class="keyword">char</span> c = <span class="string">'a'</span>;</div><div class="line">    pc = &amp;i;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; *(<span class="keyword">int</span> *)pc &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    pc = &amp;c;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; *(<span class="keyword">char</span> *)pc &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h4><p>调用函数时系统要付出一定的开销，用于信息入栈出栈和参数传递等。<br>C++引进了内联函数(inline function)的概念。在进行程序的编译时，编译器将内联函数的目标代码作拷贝并将其插入到调用内联函数的地方。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">circle</span><span class="params">(<span class="keyword">double</span> r)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">3.1416</span> * r * r;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"r = "</span> &lt;&lt; i &lt;&lt; <span class="string">" area = "</span> &lt;&lt; circle(i) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>说明：<br>（1）内联函数在第一次被调用前必须进行声明或定义。否则编译器无法知道应该插入什么代码<br>（2）C++的内联函数具有与C中的宏定义<code>#define</code>相同的作用和类似机理，但消除了<code>#define</code>的不安全性。<br>（3）内联函数体内一般不能有循环语句和开关语句。<br>（4）后面类结构中所有在类说明体内定义的函数都是内联函数。<br>（5）通常较短的函数才定义为内联函数。</p>
<h4 id="带有缺省参数值的函数"><a href="#带有缺省参数值的函数" class="headerlink" title="带有缺省参数值的函数"></a>带有缺省参数值的函数</h4><p>在C++中，函数的参数可以有缺省值。当调用有缺省参数的函数时，如果相应的参数没有给出实参，则自动用相应的缺省参数作为其实参。函数的缺省参数，是在<strong>函数原型</strong>中给定的。<br>说明<br>（1）在<strong>函数原型</strong>中，所有取缺省值的参数必须出现在不取缺省值的参数的右边。<br>（2）在<strong>函数调用</strong>时，若某个参数省略，则其后的参数皆应省略而采用缺省值。</p>
<h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>函数重载是指一个函数可以和<strong>同一作用域</strong>（命名空间）中的其他函数具有<strong>相同的名字</strong>，但这些同名函数的<strong>参数类型</strong>、<strong>参数个数</strong>不同。<br>为什么要使用函数重载？<br>对于具有同一功能的函数，如果只是由于参数类型不一样，则可以定义相同名称的函数。</p>
<p>调用步骤：<br>（1）寻找一个严格的匹配，即：调用与实参的数据类型、个数完全相同的那个函数。<br>（2）通过内部转换寻求一个匹配，即：通过（1）的方法没有找到相匹配的函数时，则由C++系统对实参的数据类型进行内部转换，转换完毕后，如果有匹配的函数存在，则执行该函数。<br>（3）通过用户定义的转换寻求一个匹配，若能查出有唯一的一组转换，就调用那个函数。即：在函数调用处由程序员对实参进行<strong>强制类型转换</strong>，以此作为查找相匹配的函数的依据。</p>
<p>注意事项：<br>重载函数不能只是函数的返回值不同，应至少在<strong>形参的个数</strong>、参数<strong>类型</strong>或参数<strong>顺序</strong>上有所不同。<br>应使所有的重载函数的功能相同。如果让重载函数完成不同的功能，会破坏程序的可读性。</p>
<p><strong>函数模板</strong><br>函数模板：建立一个通用函数，其函数类型和形参类型不具体指定，而是一个虚拟类型。<br>应用情况：凡是函数体相同的函数都可以用这个模板来代替，不必定义多个函数，只需在模板中定义一次即可。在调用函数时系统会根据实参的类型来取代模板中的虚拟类型，从而实现了不同函数的功能。<br><code>template&lt;typename T&gt;通用函数定义</code>，<code>template&lt;class T&gt;通用函数定义</code>(class和typename可以通用)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">if</span> (b &gt; a) <span class="keyword">return</span> b;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">return</span> a;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>与重载函数比较：用函数模板比函数重载更方便，程序更简洁。但应注意它只适用于：<strong>函数参数个数相同而类型不同，且函数体相同</strong>的情况。如果参数的个数不同，则不能用函数模板。</p>
<h4 id="作用域标识符"><a href="#作用域标识符" class="headerlink" title="作用域标识符::"></a>作用域标识符::</h4><p>通常情况下，如果有两个同名变量，一个是全局的，另一个是局部的，那么局部变量在其作用域内具有较高的优先权。<br>在全局变量加上<code>::</code>，此时<code>::var</code>代表全局变量。</p>
<h4 id="无名联合"><a href="#无名联合" class="headerlink" title="无名联合"></a>无名联合</h4><p>无名联合是C++中的一种特殊联合，可以声明一组无标记名共享同一段内存地址的数据项。如: <code>union {int i; float j;}</code><br>在此无名联合中，声明了变量i和f具有相同的存储地址。无名联合可通过使用其中数据项名字直接存取，例如可以直接使用上面的变量i或f。</p>
<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>C中数据类型转换的一般形式 (数据类型标识符) 表达式<br>C++支持这样的格式，还提供了一种更为方便的函数调用方法，即将类型名作为函数名使用，是的类型转换的执行看起来好像调用了一个函数。形式为：数据类型标识符 (表达式)。</p>
<h4 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h4><p>作为对C语言中malloc和free的替换，C++引进了new和delete操作符。它们的功能是<strong>实现内存的动态分配和释放</strong>。<br><code>指针变量=new 数据类型;</code><br>或<br><code>指针变量=new 数据类型(初始值);</code></p>
<p>例如：<br><code>int *a, *b;</code><br><code>a = new int;</code><br><code>b = new int(10);</code></p>
<p>释放由new操作动态分配的内存时，用delete操作。<br><code>delete 指针变量;</code><br>例如<code>delete a;</code>，<code>delete b;</code>。</p>
<p>优点：<br>（1）new和delete操作自动计算需要分配和释放类型的长度。这不但<strong>省去了用sizeof计算长度</strong>的步骤，更主要的是避免了内存分配和释放时因长度出错带来的严重后果。<br>（2）new操作自动返回需分配类型的指针，<strong>无需使用强制类型转换</strong>。<br>（3）new操作能初始化所分配的类型变量。<br>（4）new和delete都<strong>可以被重载</strong>，允许建立自定义的内存管理法。</p>
<p>说明：<br>（1）用new分配的空间，使用结束后应该用delete显示的释放，否则这部分空间将不能回收而变成死空间。<br>（2）使用new动态分配内存时，如果没有足够的内存满足分配要求，new将返回空指针（NULL）。因此通常要对内存的动态分配是否成功进行检查。<br>（3）使用new可以为数组动态分配内存空间。这时需要在类型后面加上数组大小。<br><code>指针变量 = new 类型名[下标表达式];</code><br>使用new为多维数组分配空间时，必须提供所有维的大小。<br>（4）释放动态分配的数组存储区时，可使用delete运算符</p>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>引用就是某一变量（目标）的一个别名，这样对引用的操作就是对目标的操作。<br>引用的声明方法：<code>类型标识符 &amp;引用名=目标变量名;</code><br>说明：<br>（1）<code>&amp;</code>在此不是求地址运算，而是起标识作用。<br>（2）<strong>类型</strong>标识符是指目标变量的类型。<br>（3）声明引用时，必须同时对其进行<strong>初始化</strong>。<br>（4）引用声明完毕后，相当于目标变量名有两个名称。<br>（5）声明一个引用，不是新定义了一个变量，系统并不给引用分配存储单元。</p>
<p>引用的使用<br>（1）引用名可以是任何合法的变量名。除了用作函数的参数或返回类型外，在声明时，必须立即对它进行初始化，不能声明完后再赋值。<br>（2）引用不能重新赋值，不能再把该引用名作为其他变量名的别名，任何对该引用的赋值就是该引用对应的目标变量名的赋值。对引用求地址，就是对目标变量求地址。<br>（3）由于指针变量也是变量，所以，可以声明一个指针变量的引用。方法是<code>类型标识符 *&amp;引用名=指针变量名</code><br>（4）引用是对某一变量或目标对象的引用，它本身不是一种数据类型，因此引用本身不占存储单元，这样，就不能声明引用的引用，也不能定义引用的指针。<br>（5）不能建立数组的引用，因为数组是一个由若干个元素所组成的集合，所以就无法建立一个数组的别名。<br>（6）不能建立空指针的引用。<br>（7）不能建立空类型void的引用。<br>（8）尽管引用运算符与地址操作符使用相同的符号，但是不一样的。引用仅在声明时带有引用运算符<code>&amp;</code>，以后就像普通变量一样使用，不能再带<code>&amp;</code>。其他场合使用的<code>&amp;</code>都是地址操作符。</p>
<p>用引用作为函数的参数<br>一个函数的参数可以定义成引用的形式。<br>在主调函数的调用点处，直接以<strong>变量</strong>作为<strong>实参</strong>进行调用即可，不需要实参变量有任何的特殊要求。</p>
<p>用引用返回函数值<br>函数可以返回一个引用，将函数说明为返回一个引用。<br>主要目的是：为了将函数用在赋值运算符的左边。要以引用返回函数值。<br><code>类型标识符 &amp;函数名 (形参列表及类型说明){函数体}</code><br>（1）以引用返回函数值，定义函数时需要在函数名前加<code>&amp;</code><br>（2）用引用返回一个函数值的最大好处是，在内存中不产生返回值的副本。<br>在定义返回引用的函数时，注意不要返回该函数内的自动变量（局部变量）的引用，由于自动变量的生存期仅限于函数内部，当函数返回时，自动变量就消失了。</p>
<p>一个返回引用的函数值<strong>作为赋值表达式的左值</strong>。<br>一般情况下，赋值表达式的左边只能是变量名，即被赋值的对象必须是变量，只有变量才能被赋值。</p>
<h2 id="Lecture-2"><a href="#Lecture-2" class="headerlink" title="Lecture 2"></a>Lecture 2</h2><p>类的构成<br>数据成员、成员函数</p>
<h4 id="private-protected-public"><a href="#private-protected-public" class="headerlink" title="private, protected, public"></a>private, protected, public</h4><p>· <code>private</code> 部分称为类的私有部分，这一部分的数据成员和成员函数称为类的私有成员。私有成员只能由本类的成员函数访问，而类外部的任何访问都是非法的。（只能在定义、实现的时候访问）<br>· <code>public</code> 部分称为类的共有部分，这部分的数据成员和成员函数称为类的公有成员。公有成员可以由程序中的函数访问，它对外是完全开放的。<br>· <code>protected</code> 部分称为类的保护部分，这部分的数据成员和成员函数称为类的保护成员。保护成员可以由本类的成员函数访问，也可以由本类的派生类的成员函数访问，而类外的任何访问都是非法的。</p>
<p>（1）类声明格式中的3个部分并非一定要全有，但至少要有其中的一个部分。<br>一般一个类的数据成员应该声明为私有成员，成员函数声明为公有成员。<br>（2）类声明中的private, protected, public三个关键字可以按任意顺序出现任意次。但是，如果把所有的私有成员、保护成员和公有成员归类放在一起，程序将更加清晰。<br>（3）private处于类体重第一部分时，关键字private可以省略。<br>（4）数据成员可以是任何数据类型，但不能用自动(auto)、寄存器(register)或外部(extern)进行声明。<br>（5）不能在类声明中给数据成员赋值。C++规定，只有在类对象定义之后才能给数据成员赋初值。</p>
<p>类成员的访问属性<br>类的成员对类对象的可见性和对类的成员函数的可见性是不同的。<br>类的成员函数可以访问类的所有成员，而类的对象对类的成员的访问是受类成员的访问属性的制约的。</p>
<p>一般来说，公有成员是类的对外接口，而私有成员和保护成员是类的内部数据和内部实现，不希望外界访问。将类的成员划分为不同的访问级别有两个好处：一是信息隐蔽，即实现封装；二是数据保护，即将类的重要信息保护起来，以免其他程序不恰当地修改。</p>
<p>对象赋值语句<br>两个同类型的变量之间可以相互赋值。同类型的对象间也可以进行赋值，当一个对象赋值给另一个对象时，所有的数据成员都会逐位拷贝。<br>说明：<br>·在使用对象赋值语句进行对象赋值时，两个对象的类型必须相同，如果对象的类型不同，编译时将出错。<br>·两个对象之间的赋值，仅仅使这些对象中数据成员相同，而两个对象仍是分离的。<br>·<code>=</code>的对象赋值是通过缺省的赋值运算符函数实现的。（复杂的需要重载）<br>·当类中存在指针时，使用缺省的赋值运算符进行对象赋值，可能会产生错误。</p>
<h2 id="Lecture-3"><a href="#Lecture-3" class="headerlink" title="Lecture 3"></a>Lecture 3</h2><h4 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h4><p>构造函数和析构函数都是类的成员函数，但它们都是特殊的成员函数，执行特殊的功能，不用调用便自动执行，而且这些函数的名字与类的名字有关。<br>C++语言中有一些成员函数性质是特殊的，这些成员函数负责对象的建立、删除。这些函数的特殊性在于可以由编译器自动地隐含调用，其中一些函数调用格式采用运算符函数重载的语法。C++引进一个自动完成对象初始化过程的机制，这就是类的构造函数。</p>
<p>对象的初始化<br>1）数据成员是不能在声明类时初始化<br>2）类型对象的初始化方法：<br>·调用对外接口(public成员函数)实现 声明类→定义对象→调用接口给成员赋值<br>·应用构造函数(constructor)实现 声明类→定义对象→同时给成员赋值</p>
<p>构造函数<br>构造函数是一种特殊的成员函数，它主要用于为对象分配空间，进行初始化。构造函数具有一些特殊的性质：<br>（1）构造函数的名字必须与类名相同。<br>（2）构造函数可以有任意类型的参数，但不能指定返回类型。它有隐含的返回值，该值由系统内部使用。<br>（3）构造函数是特殊的成员函数，函数体可写在类体内，也可写在类体外。<br>（4）构造函数可以重载，即一个类中可以定义多个参数个数或参数类型不同的构造函数。构造函数是不能继承。<br>（5）构造函数被声明为公有函数，但它不能像其他成员函数那样被显式地调用，它是在定义对象的同时调用的<br>·在声明类时如果没有定义类的构造函数，编译系统就会在编译时自动生成一个默认形式的构造函数。<br>·默认构造函数是构造对象时不提供参数的构造函数。<br>·除了无参数构造函数是默认构造函数外，带有全部默认参数值的构造函数也是默认构造函数。<br>·自动调用：构造函数在定义类对象时自动调用，不需用户调用，也不能被用户调用。在对象使用前调用。<br>·调用顺序：在对象进入其作用域时（对象使用前）调用构造函数。</p>
<p>利用构造函数创建对象的两种方法：<br>（1）利用构造函数直接创建对象，其一般形式为：<code>类名 对象名[(实参表)];</code><br>这里的“类名”与构造函数名相同，“实参表”是为构造函数提供的实际参数。<br>（2）利用构造函数创建对象时，通过指针和new来实现。其一般语法形式为：<code>类名 *指针变量 = new 类名 [(实参表)];</code></p>
<p>例2.19 用<code>p2 = p1</code>试一下0.0</p>
<p>析构函数<br>析构函数也是一种特殊的成员函数。它执行与构造函数相反的操作，通常用于撤销对象时的一些清理任务，如释放分配给对象的内存空间等。<br>析构函数有以下一些特点：<br>①析构函数与构造函数名字相同，但它前面必须加一个波浪号(~)；<br>②析构函数没有参数，也没有返回值，而且不能重载。因此在一个类中只能有一个析构函数；<br>③当撤销对象时，编译系统会自动调用析构函数。如果程序员没有定义析构函数，系统将自动生成和调用一个默认析构函数，默认析构函数只能释放对象的数据成员所占用的空间，但不包括堆内存空间。</p>
<h2 id="Lecture-7-8"><a href="#Lecture-7-8" class="headerlink" title="Lecture 7-8"></a>Lecture 7-8</h2><h3 id="继承与派生类"><a href="#继承与派生类" class="headerlink" title="继承与派生类"></a>继承与派生类</h3><p>继承目的：代码的重用和代码的扩充<br>继承方法程序设计思路：一般-&gt;特殊<br>继承种类：单继承、多继承<br>继承方式：public protected private<br>继承内容：除构造函数、析构函数、私有成员外的其他成员</p>
<p>保持已有类的特性而构造新类的过程称为<strong>继承</strong>。<br>在已有类的基础上新增自己的特性而产生新类的过程称为<strong>派生</strong>。<br>被继承的已有类称为基类（父类）。<br>派生出的新类称为派生类。</p>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    Hael Chan
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://haelchan.me/2018/03/14/oop-note/" title="面向对象程序设计课堂笔记">http://haelchan.me/2018/03/14/oop-note/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/learning-note/" rel="tag"># learning note</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/02/18/deep-learning-note/" rel="next" title="deep-learning-note">
                <i class="fa fa-chevron-left"></i> deep-learning-note
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/03/31/NLP-note/" rel="prev" title="COMS W4705 Natural Language Processing Note">
                COMS W4705 Natural Language Processing Note <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>
  


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Hael Chan" />
            
              <p class="site-author-name" itemprop="name">Hael Chan</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/haelchan" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:f.procumbens@gmail.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://twitter.com/Procumbens" target="_blank" title="Twitter">
                    
                      <i class="fa fa-fw fa-twitter"></i>Twitter</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.zhihu.com/people/hael-c/activities" target="_blank" title="知乎">
                    
                      <i class="fa fa-fw fa-zhihu"></i>知乎</a>
                </span>
              
            
          </div>

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-globe"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://learnerwn.github.io" title="WN_Blog" target="_blank">WN_Blog</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://ruder.io" title="Sebastian Ruder" target="_blank">Sebastian Ruder</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Lecture-1"><span class="nav-number">1.</span> <span class="nav-text">Lecture 1</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#序"><span class="nav-number">1.1.</span> <span class="nav-text">序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本概念"><span class="nav-number">1.2.</span> <span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对象"><span class="nav-number">1.2.1.</span> <span class="nav-text">对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类"><span class="nav-number">1.2.2.</span> <span class="nav-text">类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#消息"><span class="nav-number">1.2.3.</span> <span class="nav-text">消息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法"><span class="nav-number">1.2.4.</span> <span class="nav-text">方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面向对象程序设计的基本特征"><span class="nav-number">1.3.</span> <span class="nav-text">面向对象程序设计的基本特征</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#抽象"><span class="nav-number">1.3.1.</span> <span class="nav-text">抽象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#封装"><span class="nav-number">1.3.2.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#继承"><span class="nav-number">1.3.3.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多态"><span class="nav-number">1.3.4.</span> <span class="nav-text">多态</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-对C的补充"><span class="nav-number">1.4.</span> <span class="nav-text">C++对C的补充</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#注释与续行"><span class="nav-number">1.4.1.</span> <span class="nav-text">注释与续行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#输入输出流"><span class="nav-number">1.4.2.</span> <span class="nav-text">输入输出流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#灵活的变量说明"><span class="nav-number">1.4.3.</span> <span class="nav-text">灵活的变量说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#结构、联合和枚举名"><span class="nav-number">1.4.4.</span> <span class="nav-text">结构、联合和枚举名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数原型"><span class="nav-number">1.4.5.</span> <span class="nav-text">函数原型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#const修饰符"><span class="nav-number">1.4.6.</span> <span class="nav-text">const修饰符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#void型指针"><span class="nav-number">1.4.7.</span> <span class="nav-text">void型指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内联函数"><span class="nav-number">1.4.8.</span> <span class="nav-text">内联函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#带有缺省参数值的函数"><span class="nav-number">1.4.9.</span> <span class="nav-text">带有缺省参数值的函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数重载"><span class="nav-number">1.4.10.</span> <span class="nav-text">函数重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#作用域标识符"><span class="nav-number">1.4.11.</span> <span class="nav-text">作用域标识符::</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#无名联合"><span class="nav-number">1.4.12.</span> <span class="nav-text">无名联合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#强制类型转换"><span class="nav-number">1.4.13.</span> <span class="nav-text">强制类型转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态内存分配"><span class="nav-number">1.4.14.</span> <span class="nav-text">动态内存分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#引用"><span class="nav-number">1.4.15.</span> <span class="nav-text">引用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lecture-2"><span class="nav-number">2.</span> <span class="nav-text">Lecture 2</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#private-protected-public"><span class="nav-number">2.0.1.</span> <span class="nav-text">private, protected, public</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lecture-3"><span class="nav-number">3.</span> <span class="nav-text">Lecture 3</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#构造函数与析构函数"><span class="nav-number">3.0.1.</span> <span class="nav-text">构造函数与析构函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lecture-7-8"><span class="nav-number">4.</span> <span class="nav-text">Lecture 7-8</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#继承与派生类"><span class="nav-number">4.1.</span> <span class="nav-text">继承与派生类</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hael Chan</span>

  
</div>









<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

<span id="busuanzi_container_site_uv">
  欢迎~您是本站的第<span id="busuanzi_value_site_uv"></span>位访客
</span>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  

    
      <script id="dsq-count-scr" src="https://hael.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://haelchan.me/2018/03/14/oop-note/';
          this.page.identifier = '2018/03/14/oop-note/';
          this.page.title = '面向对象程序设计课堂笔记';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://hael.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'manual') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("3HhWLTewaKTSPj5DC3qp5b2m-gzGzoHsz", "zjxN2hpHQEmyMaz0XBicI3bn");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  


  

  

</body>
</html>
